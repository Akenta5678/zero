{
  "language": "Solidity",
  "sources": {
    "contracts/ActivePool.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport './Interfaces/IPool.sol';\n// import '@openzeppelin/contracts/ownership/Ownable.sol';\n// import '@openzeppelin/contracts/math/SafeMath.sol';\n// import \"@nomiclabs/buidler/console.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract ActivePool is Ownable, IPool {\n    using SafeMath for uint256;\n\n    address public poolManagerAddress;\n    address public stabilityPoolAddress;\n    address public defaultPoolAddress;\n    uint256 public ETH;  // deposited ether tracker\n    uint256 public CLV;  // total outstanding CDP debt\n\n    constructor() public {}\n\n    // --- Contract setters ---\n\n    function setPoolManagerAddress(address _poolManagerAddress) public onlyOwner {\n        poolManagerAddress = _poolManagerAddress;\n        emit PoolManagerAddressChanged(_poolManagerAddress);\n    }\n\n    function setDefaultPoolAddress(address _defaultPoolAddress) public onlyOwner {\n        defaultPoolAddress = _defaultPoolAddress; \n        emit DefaultPoolAddressChanged(defaultPoolAddress);\n    }\n\n    function setStabilityPoolAddress(address _stabilityPoolAddress) public onlyOwner {\n        stabilityPoolAddress = _stabilityPoolAddress;\n        emit StabilityPoolAddressChanged(stabilityPoolAddress);\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getETH() public view returns(uint) {\n        return ETH;\n    }\n\n    function getCLV() public view returns(uint) {\n        return CLV;\n    }\n\n    // --- Pool functionality ---\n\n    function sendETH(address _account, uint _amount) public onlyPoolManager returns(bool) {\n        ETH = ETH.sub(_amount);  \n        (bool success, ) = _account.call.value(_amount)(\"\"); //  use call.value()('') as per Consensys latest advice \n        assert(success == true); \n       \n        emit EtherSent(_account, _amount);  \n        return true;\n    }\n\n    function increaseCLV(uint _amount) public onlyPoolManager () {\n        CLV  = CLV.add(_amount); \n    }\n\n    function decreaseCLV(uint _amount) public onlyPoolManager () {\n        CLV = CLV.sub(_amount); \n    }\n\n    /* Returns the raw ether balance at ActivePool address.  \n    Not necessarily equal to the ETH state variable - ether can be forcibly sent to contracts. */\n    function getRawETHBalance() public view returns(uint) {\n        return address(this).balance;\n    }\n\n    // --- Modifiers ---\n    modifier onlyPoolManager {\n        require(_msgSender() == poolManagerAddress, \"ActivePool: Caller is not the PoolManager\");\n        _;\n    }\n\n    modifier onlyPoolManagerOrPool {\n        require(\n            _msgSender() == poolManagerAddress || \n            _msgSender() == stabilityPoolAddress || \n            _msgSender() == defaultPoolAddress, \n            \"ActivePool:  Caller is neither the PoolManager nor a Pool\");\n        _;\n    }\n\n    function () external payable onlyPoolManagerOrPool {\n        ETH = ETH.add(msg.value);\n    }\n}\n"
    },
    "contracts/Interfaces/IPool.sol": {
      "content": "pragma solidity ^0.5.15;\n\n// Common interface for the Pools.\ninterface IPool {\n    // --- Events ---\n    event ETHBalanceUpdated(uint _newBalance);\n\n    event CLVBalanceUpdated(uint _newBalance);\n\n    event PoolManagerAddressChanged(address _newAddress);\n\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n\n    event EtherSent(address _to, uint _amount);\n\n    // --- Functions ---\n    function getETH() external view returns(uint);\n    \n    function getCLV() external view returns(uint);\n    \n    function sendETH(address _account, uint _amount) external returns(bool);\n\n    function increaseCLV(uint _amount) external;\n\n    function decreaseCLV(uint _amount) external;\n\n    function getRawETHBalance() external view returns(uint);\n}"
    },
    "contracts/Dependencies/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/Dependencies/Ownable.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/Dependencies/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Dependencies/console.sol": {
      "content": "pragma solidity >= 0.5.0 <0.7.0;\n// Buidler's helper contract for console logging\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction log() internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log()\"));\n\t\tignored;\n\t}\tfunction logInt(int p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(int)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logByte(byte p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(byte)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n}\n"
    },
    "contracts/BorrowerOperations.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ICDPManager.sol\";\nimport \"./Interfaces/IPool.sol\";\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Interfaces/ISortedCDPs.sol\";\nimport \"./Interfaces/IPoolManager.sol\";\nimport \"./DeciMath.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract BorrowerOperations is Ownable, IBorrowerOperations {\n    using SafeMath for uint;\n\n    uint constant public MCR = 1100000000000000000; // Minimal collateral ratio.\n    uint constant public  CCR = 1500000000000000000; // Critical system collateral ratio. If the total system collateral (TCR) falls below the CCR, Recovery Mode is triggered.\n    uint constant public MIN_COLL_IN_USD = 20000000000000000000;\n\n    // --- Events --- \n\n    event CDPManagerAddressChanged(address _newCDPManagerAddress);\n    event PoolManagerAddressChanged(address _newPoolManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedCDPsAddressChanged(address _sortedCDPsAddress);\n\n    event CDPCreated(address indexed _user, uint arrayIndex);\n    event CDPUpdated(address indexed _user, uint _debt, uint _coll, uint stake);\n   \n    // --- Connected contract declarations ---\n\n    ICDPManager cdpManager;\n    address public cdpManagerAddress;\n\n    IPoolManager poolManager;\n    address public poolManagerAddress;\n\n    IPool activePool;\n    address public activePoolAddress;\n\n    IPool defaultPool;\n    address public defaultPoolAddress;\n\n    IPriceFeed priceFeed;\n    address public priceFeedAddress;\n\n    // A doubly linked list of CDPs, sorted by their sorted by their collateral ratios\n    ISortedCDPs sortedCDPs;\n    address public sortedCDPsAddress;\n\n    // --- Dependency setters --- \n\n    function setCDPManager(address _cdpManagerAddress) public onlyOwner {\n        cdpManagerAddress = _cdpManagerAddress;\n        cdpManager = ICDPManager(_cdpManagerAddress);\n        emit CDPManagerAddressChanged(_cdpManagerAddress);\n    }\n\n    function setPoolManager(address _poolManagerAddress) public onlyOwner {\n        poolManagerAddress = _poolManagerAddress;\n        poolManager = IPoolManager(_poolManagerAddress);\n        emit PoolManagerAddressChanged(_poolManagerAddress);\n    }\n\n    function setActivePool(address _activePoolAddress) public onlyOwner {\n        activePoolAddress = _activePoolAddress;\n        activePool = IPool(_activePoolAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n    }\n\n    function setDefaultPool(address _defaultPoolAddress) public onlyOwner {\n        defaultPoolAddress = _defaultPoolAddress;\n        defaultPool = IPool(_defaultPoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n    }\n\n    function setPriceFeed(address _priceFeedAddress) public onlyOwner {\n        priceFeedAddress = _priceFeedAddress;\n        priceFeed = IPriceFeed(priceFeedAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n    }\n\n    function setSortedCDPs(address _sortedCDPsAddress) public onlyOwner {\n        sortedCDPsAddress = _sortedCDPsAddress;\n        sortedCDPs = ISortedCDPs(_sortedCDPsAddress);\n        emit SortedCDPsAddressChanged(_sortedCDPsAddress);\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openLoan(uint _CLVAmount, address _hint) public payable returns (bool) {\n        address user = _msgSender(); \n        uint price = priceFeed.getPrice(); \n\n        requireValueIsGreaterThan20Dollars(msg.value, price);\n        \n        uint ICR = computeICR(msg.value, _CLVAmount, price);  \n\n        if (_CLVAmount > 0) {\n            requireNotInRecoveryMode();\n            requireICRisAboveMCR(ICR);\n\n            requireNewTCRisAboveCCR(int(msg.value), int(_CLVAmount), price); \n        }\n        \n        // Update loan properties\n        cdpManager.setCDPStatus(user, 1);\n        cdpManager.increaseCDPColl(user, msg.value);\n        cdpManager.increaseCDPDebt(user, _CLVAmount);\n        \n        cdpManager.updateRewardSnapshots(user); \n        uint stake = cdpManager.updateStakeAndTotalStakes(user); \n        \n        sortedCDPs.insert(user, ICR, price, _hint, _hint); \n        uint arrayIndex = cdpManager.addCDPOwnerToArray(user);\n        emit CDPCreated(user, arrayIndex);\n        \n        // Tell PM to move the ether to the Active Pool, and mint CLV to the borrower\n        poolManager.addColl.value(msg.value)(); \n        poolManager.withdrawCLV(user, _CLVAmount); \n       \n        emit CDPUpdated(user, _CLVAmount, msg.value, stake); \n        return true;\n    }\n\n    // Send ETH as collateral to a CDP\n    function addColl(address _user, address _hint) public payable returns (bool) {\n        bool isFirstCollDeposit;\n\n        uint price = priceFeed.getPrice();\n        uint status = cdpManager.getCDPStatus(_user);\n    \n        // If non-existent or closed, open a new trove\n        if (status == 0 || status == 2 ) {\n            requireValueIsGreaterThan20Dollars(msg.value, price);\n\n            isFirstCollDeposit = true; \n            cdpManager.setCDPStatus(_user, 1);\n        } \n\n        cdpManager.applyPendingRewards(_user);\n       \n        // Update the CDP's coll and stake\n        uint newColl = cdpManager.increaseCDPColl(_user, msg.value);\n        uint stake = cdpManager.updateStakeAndTotalStakes(_user);\n        uint newICR = cdpManager.getCurrentICR(_user, price);\n   \n        if (isFirstCollDeposit) { \n            sortedCDPs.insert(_user, newICR, price, _hint, _hint);\n            uint arrayIndex = cdpManager.addCDPOwnerToArray(_user);\n            emit CDPCreated(_user, arrayIndex);\n        } else {\n            sortedCDPs.reInsert(_user, newICR, price, _hint, _hint);  \n        }\n\n        // Tell PM to move the ether to the Active Pool\n        poolManager.addColl.value(msg.value)();\n  \n        uint debt = cdpManager.getCDPDebt(_user);\n        emit CDPUpdated(_user, debt, newColl, stake);\n        return true;\n    }\n    \n    // Withdraw ETH collateral from a CDP\n    function withdrawColl(uint _amount, address _hint) public returns (bool) {\n        address user = _msgSender();\n        uint status = cdpManager.getCDPStatus(user);\n        requireCDPisActive(status);\n        requireNotInRecoveryMode();\n       \n        uint price = priceFeed.getPrice();\n        cdpManager.applyPendingRewards(user);\n\n        uint debt = cdpManager.getCDPDebt(user);\n        uint coll = cdpManager.getCDPColl(user);\n        \n        requireCollAmountIsWithdrawable(coll, _amount, price);\n\n        uint newICR = getNewICRFromTroveChange(coll, debt, -int(_amount), 0, price);\n        requireICRisAboveMCR(newICR);\n        \n        // Update the CDP's coll and stake\n        cdpManager.decreaseCDPColl(user, _amount);\n        uint stake = cdpManager.updateStakeAndTotalStakes(user);\n\n        uint newColl = coll.sub(_amount);\n\n        if (newColl == 0) { \n            cdpManager.closeCDP(user);  \n        }  else { \n            sortedCDPs.reInsert(user, newICR, price, _hint, _hint);\n        }\n\n        // Remove _amount ETH from ActivePool and send it to the user\n        poolManager.withdrawColl(user, _amount);\n\n        emit CDPUpdated(user, debt, newColl, stake); \n        return true;\n    }\n    \n    // Withdraw CLV tokens from a CDP: mint new CLV to the owner, and increase the debt accordingly\n    function withdrawCLV(uint _amount, address _hint) public returns (bool) {\n        address user = _msgSender();\n        uint status = cdpManager.getCDPStatus(user);\n        requireCDPisActive(status);\n        requireNonZeroAmount(_amount); \n        requireNotInRecoveryMode();\n        \n        uint price = priceFeed.getPrice();\n        cdpManager.applyPendingRewards(user);\n\n        uint coll = cdpManager.getCDPColl(user);\n        uint debt = cdpManager.getCDPDebt(user);\n\n        uint newICR = getNewICRFromTroveChange(coll, debt, 0, int(_amount), price);\n        requireICRisAboveMCR(newICR);\n\n        requireNewTCRisAboveCCR(0, int(_amount), price);\n        \n        // Increase the CDP's debt\n        uint newDebt = cdpManager.increaseCDPDebt(user, _amount);\n       \n        // Update CDP's position in sortedCDPs\n        sortedCDPs.reInsert(user, newICR, price, _hint, _hint);\n\n        // Mint the given amount of CLV to the owner's address and add them to the ActivePool\n        poolManager.withdrawCLV(user, _amount);\n        \n        uint stake = cdpManager.getCDPStake(user);\n        emit CDPUpdated(user, newDebt, coll, stake); \n        return true; \n    }\n    \n    // Repay CLV tokens to a CDP: Burn the repaid CLV tokens, and reduce the debt accordingly\n    function repayCLV(uint _amount, address _hint) public returns (bool) {\n        address user = _msgSender();\n        uint status = cdpManager.getCDPStatus(user);\n        requireCDPisActive(status);\n\n        uint price = priceFeed.getPrice();\n        cdpManager.applyPendingRewards(user);\n\n        uint debt = cdpManager.getCDPDebt(user);\n        requireCLVRepaymentAllowed(debt, -int(_amount));\n        \n        // Update the CDP's debt\n        uint newDebt = cdpManager.decreaseCDPDebt(user, _amount);\n       \n        uint newICR = cdpManager.getCurrentICR(user, price);\n        \n        // Update CDP's position in sortedCDPs\n        sortedCDPs.reInsert(user, newICR, price, _hint, _hint);\n\n        // Burn the received amount of CLV from the user's balance, and remove it from the ActivePool\n        poolManager.repayCLV(user, _amount);\n        \n        uint coll = cdpManager.getCDPColl(user);\n        uint stake = cdpManager.getCDPStake(user);\n        emit CDPUpdated(user, newDebt, coll, stake); \n        return true;\n    }\n\n    function closeLoan() public returns (bool) {\n        address user = _msgSender();\n        uint status = cdpManager.getCDPStatus(user);\n        requireCDPisActive(status);\n        requireNotInRecoveryMode();\n\n        cdpManager.applyPendingRewards(user);\n        \n        uint coll = cdpManager.getCDPColl(user);\n        uint debt = cdpManager.getCDPDebt(user);\n\n        cdpManager.removeStake(user);\n        cdpManager.closeCDP(user);\n    \n        // Tell PM to burn the debt from the user's balance, and send the collateral back to the user\n        poolManager.repayCLV(user, debt);\n        poolManager.withdrawColl(user, coll);\n\n        emit CDPUpdated(user, 0, 0, 0);\n        return true; \n    }\n\n    /* If ether is sent, the operation is considered as an increase in ether, and the first parameter \n    _collWithdrawal is ignored  */\n    function adjustLoan(uint _collWithdrawal, int _debtChange, address _hint) public payable returns (bool) {\n        requireCDPisActive(cdpManager.getCDPStatus(_msgSender()));\n        requireNotInRecoveryMode();\n        \n        uint price = priceFeed.getPrice();\n     \n        cdpManager.applyPendingRewards(_msgSender());\n\n        // If Ether is sent, grab the amount. Otherwise, grab the specified collateral withdrawal\n        int collChange = (msg.value != 0) ? int(msg.value) : -int(_collWithdrawal);\n\n        uint debt = cdpManager.getCDPDebt(_msgSender());\n        uint coll = cdpManager.getCDPColl(_msgSender());\n       \n        uint newICR = getNewICRFromTroveChange(coll, debt, collChange, _debtChange, price);\n       \n        // --- Checks --- \n        requireICRisAboveMCR(newICR);\n        requireNewTCRisAboveCCR(collChange, _debtChange, price);\n        requireCLVRepaymentAllowed(debt, _debtChange);\n        requireCollAmountIsWithdrawable(coll, _collWithdrawal, price);\n\n        //  --- Effects --- \n        (uint newColl, uint newDebt) = updateTroveFromAdjustment(_msgSender(), collChange, _debtChange);\n        \n        uint stake = cdpManager.updateStakeAndTotalStakes(_msgSender());\n       \n        // Close a CDP if it is empty, otherwise, re-insert it in the sorted list\n        if (newDebt == 0 && newColl == 0) {\n            cdpManager.closeCDP(_msgSender());\n        } else {\n            sortedCDPs.reInsert(_msgSender(), newICR, price, _hint, _hint);\n        }\n\n        //  --- Interactions ---\n        moveTokensAndETHfromAdjustment(_msgSender(), collChange, _debtChange);   \n    \n        emit CDPUpdated(_msgSender(), newDebt, newColl, stake); \n        return true;\n    }\n\n    // --- Helper functions --- \n\n    /* Converts the magnitude of an int to a uint\n    TODO:  check validity for num in region (num > 2**255) or (num < -2**255) */\n    function intToUint(int num) internal pure returns (uint) {\n        if (num < 0) {\n            return uint(-num);\n        } else {\n            return uint(num);\n        }\n    }\n\n    function getUSDValue(uint _coll, uint _price) internal view returns (uint) {\n        uint usdValue = _price.mul(_coll).div(1e18);\n\n        return usdValue;\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function updateTroveFromAdjustment(address _user, int _collChange, int _debtChange ) internal returns (uint, uint) {\n        uint newColl = (_collChange > 0) ? cdpManager.increaseCDPColl(_user, intToUint(_collChange)) \n                                         : cdpManager.decreaseCDPColl(_user, intToUint(_collChange));\n        uint newDebt = (_debtChange > 0) ? cdpManager.increaseCDPDebt(_user, intToUint(_debtChange)) \n                                         : cdpManager.decreaseCDPDebt(_user, intToUint(_debtChange));\n\n        return (newColl, newDebt);\n    }\n\n    function moveTokensAndETHfromAdjustment(address _user, int _collChange, int _debtChange) internal {\n        if (_collChange > 0 ) {\n            poolManager.addColl.value(intToUint(_collChange))();\n        } else if (_collChange < 0) {\n            poolManager.withdrawColl(_user, intToUint(_collChange));\n        }\n\n        if (_debtChange > 0){\n            poolManager.withdrawCLV(_user, intToUint(_debtChange));\n        } else if (_debtChange < 0) {\n            poolManager.repayCLV(_user, intToUint(_debtChange));\n        }\n    }\n    \n    // --- 'Require' wrapper functions ---\n\n    function requireCDPisActive(uint status) internal view {\n        require(status == 1, \"CDPManager: CDP does not exist or is closed\");\n    }\n\n    function requireNotInRecoveryMode() internal view {\n        require(checkRecoveryMode() == false, \"CDPManager: Operation not permitted during Recovery Mode\");\n    }\n\n    function requireICRisAboveMCR(uint _newICR)  internal view {\n        require(_newICR >= MCR, \"CDPManager: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function requireNewTCRisAboveCCR(int _collChange, int _debtChange, uint _price) internal view {\n        uint newTCR = getNewTCRFromTroveChange(_collChange, _debtChange, _price);\n        require(newTCR >= CCR, \"CDPManager: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function requireCLVRepaymentAllowed(uint _currentDebt, int _debtChange) internal pure {\n        if (_debtChange < 0) {\n            require(intToUint(_debtChange) <= _currentDebt, \"CDPManager: Amount repaid must not be larger than the CDP's debt\");\n        }\n    }\n\n    function requireValueIsGreaterThan20Dollars(uint _amount, uint _price) internal view {\n         require(getUSDValue(_amount, _price) >= MIN_COLL_IN_USD,  \n            \"CDPManager: Collateral must have $USD value >= 20\");\n    }\n\n    function requireNonZeroAmount(uint _amount) internal pure {\n        require(_amount > 0, \"CDPManager: Amount must be larger than 0\");\n    }\n\n    function requireCollAmountIsWithdrawable(uint _currentColl, uint _collWithdrawal, uint _price) \n    internal \n    view \n    {\n        if (_collWithdrawal > 0) {\n            require(_collWithdrawal <= _currentColl, \"CDPManager: Insufficient balance for ETH withdrawal\");\n            \n            uint newColl = _currentColl.sub(_collWithdrawal);\n            require(getUSDValue(newColl, _price) >= MIN_COLL_IN_USD || newColl == 0,\n                \"CDPManager: Remaining collateral must have $USD value >= 20, or be zero\");\n        }\n    }\n\n    // --- ICR and TCR checks ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function getNewICRFromTroveChange(uint _coll, uint _debt, int _collChange, int _debtChange, uint _price) \n    view\n    internal \n    returns(uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        if (_collChange > 0) {\n            newColl = _coll.add(intToUint(_collChange));\n        } else if (_collChange < 0) {\n            newColl = _coll.sub(intToUint(_collChange));\n        }\n\n        if (_debtChange > 0) {\n            newDebt = _debt.add(intToUint(_debtChange));\n        } else if (_debtChange < 0) {\n            newDebt = _debt.sub(intToUint(_debtChange));\n        }\n\n        return computeICR(newColl, newDebt, _price);\n    }\n\n    function getNewTCRFromTroveChange(int _collChange, int _debtChange, uint _price) internal view returns (uint) {\n        uint totalColl = activePool.getETH().add(defaultPool.getETH());\n        uint totalDebt = activePool.getCLV().add(defaultPool.getCLV());\n       \n        if (_collChange > 0) {\n            totalColl = totalColl.add(intToUint(_collChange));\n        } else if (_collChange < 0) {\n            totalColl = totalColl.sub(intToUint(_collChange));\n        }\n\n        if (_debtChange > 0) {\n            totalDebt = totalDebt.add(intToUint(_debtChange));\n        } else if (_debtChange < 0) {\n            totalDebt = totalDebt.sub(intToUint(_debtChange));\n        }\n\n        uint newTCR = computeICR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    // --- Common helper functions, duplicated in CDPManager ---\n\n    function checkRecoveryMode() internal view returns (bool){\n        uint price = priceFeed.getPrice();\n\n        uint activeColl = activePool.getETH();\n        uint activeDebt = activePool.getCLV();\n        uint liquidatedColl = defaultPool.getETH();\n        uint closedDebt = defaultPool.getCLV();\n\n        uint totalCollateral = activeColl.add(liquidatedColl);\n        uint totalDebt = activeDebt.add(closedDebt); \n\n        uint TCR = computeICR(totalCollateral, totalDebt, price); \n        \n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function computeICR(uint _coll, uint _debt, uint _price) view internal returns(uint) {\n        // Check if the total debt is higher than 0, to avoid division by 0\n        if (_debt > 0) {\n\n            // Pure division to decimal\n            uint newCollRatio = _coll.mul(_price).div(_debt);\n\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the CDP has a debt of 0\n        else {\n            return (2**256) - 1; \n        }\n    }\n}\n\n\n\n\n"
    },
    "contracts/Interfaces/IBorrowerOperations.sol": {
      "content": "pragma solidity ^0.5.15;\n\n// Common interface for the CDP Manager.\ninterface IBorrowerOperations {\n\n    // --- Events ---\n\n    event CDPManagerAddressChanged(address _newCDPManagerAddress);\n\n    event PoolManagerAddressChanged(address _newPoolManagerAddress);\n\n    event ActivePoolAddressChanged(address _activePoolAddress);\n\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    \n    event SortedCDPsAddressChanged(address _sortedCDPsAddress);\n\n    // --- Functions ---\n\n    function setCDPManager(address _CDPManagerAddress) external;\n\n    function setPoolManager(address _poolManagerAddress) external;\n\n    function setPriceFeed(address _priceFeedAddress) external;\n\n    function setSortedCDPs(address _sortedCDPsAddress) external;\n\n    function setActivePool(address _activePoolAddress) external; \n\n    function setDefaultPool(address _defaultPoolAddress) external;\n\n    function openLoan(uint _CLVAmount, address _hint) external payable returns(bool);\n\n    function addColl(address _user, address _hint) external payable returns(bool);\n\n    function withdrawColl(uint _amount, address _hint) external returns(bool);\n\n    function withdrawCLV(uint _amount, address _hint) external returns(bool);\n\n    function repayCLV(uint _amount, address _hint) external returns(bool);\n\n    function closeLoan() external returns (bool);\n\n    function adjustLoan(uint _collWithdrawal, int _debtChange, address _hint) external payable returns(bool);\n}"
    },
    "contracts/Interfaces/ICDPManager.sol": {
      "content": "pragma solidity ^0.5.15;\n\n// Common interface for the CDP Manager.\ninterface ICDPManager {\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n\n    event PoolManagerAddressChanged(address _newPoolManagerAddress);\n\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n\n    event CLVTokenAddressChanged(address _newCLVTokenAddress);\n\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    \n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n\n    event SortedCDPsAddressChanged(address _sortedCDPsAddress);\n\n    event CDPCreated(address indexed _user, uint arrayIndex);\n\n    event CDPUpdated(address indexed _user, uint _debt, uint _coll, uint stake);\n\n    // --- Functions ---\n\n    function setPoolManager(address _poolManagerAddress) external;\n\n    function setPriceFeed(address _priceFeedAddress) external;\n\n    function setCLVToken(address _clvTokenAddress) external;\n\n    function setSortedCDPs(address _sortedCDPsAddress) external;\n\n    function setActivePool(address _activePoolAddress) external; \n\n    function setDefaultPool(address _defaultPoolAddress) external;\n\n    function getCDPOwnersCount() external view returns(uint);\n\n    function getCurrentICR(address _user, uint _price) external view returns(uint);\n\n    function getApproxHint(uint CR, uint numTrials) external view returns(address);\n\n    function liquidate(address _user) external returns(bool);\n\n    function liquidateCDPs(uint _n) external returns(bool);\n\n    function checkRecoveryMode() external view returns(bool);\n\n    function getRedemptionHints(uint _CLVamount, uint _price) external view returns (address, uint);\n\n    function redeemCollateral(\n        uint _CLVAmount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    ) external returns (bool); \n\n    function updateStakeAndTotalStakes(address _user) external returns (uint);\n\n    function updateRewardSnapshots(address _user) external returns(bool);\n\n    function addCDPOwnerToArray(address _user) external returns (uint index);\n\n    function applyPendingRewards(address _user) external returns(bool);\n\n    function closeCDP(address _user) external returns (bool);\n\n    function removeStake(address _user) external returns (bool);\n\n    function getCDPStatus(address _user) external view returns (uint);\n    \n    function getCDPStake(address _user) external view returns (uint);\n\n    function getCDPDebt(address _user) external view returns (uint);\n\n    function getCDPColl(address _user) external view returns (uint);\n\n    function setCDPStatus(address _user, uint num) external;\n\n    function increaseCDPColl(address _user, uint _collIncrease) external returns (uint);\n\n    function decreaseCDPColl(address _user, uint _collDecrease) external returns (uint); \n\n    function increaseCDPDebt(address _user, uint _debtIncrease) external returns (uint); \n\n    function decreaseCDPDebt(address _user, uint _collDecrease) external returns (uint); \n}"
    },
    "contracts/Interfaces/IPriceFeed.sol": {
      "content": "pragma solidity ^0.5.15;\n\ninterface IPriceFeed { \n    // --- Events ---\n    event PriceUpdated(uint _newPrice);\n    event CDPManagerAddressChanged(address _cdpManagerAddress);\n    event PoolManagerAddressChanged(address _poolManagerAddress);\n\n    // --- Functions ---\n    function setCDPManagerAddress(address _cdpManagerAddress) external;\n\n    function setPoolManagerAddress(address _poolManagerAddress) external;\n\n    function setPrice(uint _price) external returns(bool);\n        \n    function getPrice() external view returns(uint);\n\n    // --- Chainlink Mainnet functions ---\n    function setAggregator(address _priceAggregatorAddress) external;\n\n    function updatePrice() external returns(uint256);\n\n    function getLatestPrice() external view returns(uint256);\n\n    function getLatestAnswerID() external view returns(uint256);\n\n    function getLatestTimestamp() external view returns(uint256);\n\n    // --- Chainlink Testnet functions --- \n    function updatePrice_Testnet() external returns (uint256);\n\n    function setAggregator_Testnet(address _priceAggregatorAddress_Testnet) external;\n\n    function getLatestPrice_Testnet() external view returns (uint256);\n\n    function getLatestTimestamp_Testnet() external view returns (uint256);\n\n    function getPreviousPrice_Testnet(uint256 _n) external view returns (uint256);\n\n    function getPreviousTimestamp_Testnet(uint256 _n) external view returns (uint256);\n}\n"
    },
    "contracts/Interfaces/ISortedCDPs.sol": {
      "content": "pragma solidity ^0.5.15;\n\n// Common interface for the SortedCDPs Doubly Linked List.\ninterface ISortedCDPs {\n// --- Events ---\nevent SortedCDPsAddressChanged(address _sortedDoublyLLAddress);\nevent BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n\n// --- Functions ---\n    function setCDPManager(address _CDPManagerAddress) external;\n\n    function setBorrowerOperations(address _borrowerOperationsAddress) external;\n\n    function setMaxSize(uint256 _size) external;\n\n    function insert(address _id, uint256 _ICR, uint price, address _prevId, address _nextId) external;\n\n    function remove(address _id) external;\n\n    function reInsert(address _id, uint256 _newICR, uint price, address _prevId, address _nextId) external;\n\n    function contains(address _id) external view returns (bool);\n\n    function isFull() external view returns (bool);\n\n    function isEmpty() external view returns (bool);\n\n    function getSize() external view returns (uint256);\n\n    function getMaxSize() external view returns (uint256);\n\n    function getFirst() external view returns (address);\n\n    function getLast() external view returns (address);\n\n    function getNext(address _id) external view returns (address);\n\n    function getPrev(address _id) external view returns (address);\n\n    function validInsertPosition(uint256 _ICR, uint _price, address _prevId, address _nextId) external view returns (bool);\n\n    function findInsertPosition(uint256 _ICR, uint _price,  address _prevId, address _nextId) external view returns (address, address);\n}"
    },
    "contracts/Interfaces/IPoolManager.sol": {
      "content": "pragma solidity ^0.5.15;\n\n// Common interface for the ETH/CLV pools.\ninterface IPoolManager {\n     // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n\n    event CDPManagerAddressChanged(address _newCDPManagerAddress);\n\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n\n    event CLVTokenAddressChanged(address _newCLVTokenAddress);\n\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n\n    event UserSnapshotUpdated(uint _P, uint _S);\n\n    event P_Updated(uint _P);\n\n    event S_Updated(uint _S);\n\n    event UserDepositChanged(address indexed _user, uint _amount);\n\n    event OverstayPenaltyClaimed(address claimant, uint claimantReward, address depositor, uint remainder);\n\n    // --- Functions ---\n    function setBorrowerOperations(address _borrowerOperationsAddress) external;\n\n    function setCDPManagerAddress(address _cdpManagerAddress) external;\n\n    function setPriceFeed(address _priceFeedAddress) external;\n\n    function setCLVToken(address _CLVAddress) external;\n\n    function setStabilityPool(address _stabilityPoolAddress) external;\n\n    function setActivePool(address _activePoolAddress) external;\n\n    function setDefaultPool(address _defaultPoolAddress) external;\n    \n    function getBalance() external view returns(uint);\n    \n    function getActiveDebt() external view returns(uint);\n    \n    function getActiveColl() external view returns(uint);\n    \n    function getClosedDebt() external view returns (uint);\n    \n    function getLiquidatedColl() external view returns(uint);\n\n    function getStabilityPoolCLV() external view returns (uint);\n\n    function getCurrentETHGain(address _user) external view returns (uint);\n\n    function addColl() external payable returns(bool);\n\n    function withdrawColl(address _account, uint _ETH) external returns (bool);\n\n    function withdrawCLV(address _account, uint _CLV) external returns(bool);\n    \n    function repayCLV(address _account, uint _CLV) external returns(bool);\n\n    function liquidate(uint _CLV, uint _ETH) external returns(bool);\n  \n    function moveDistributionRewardsToActivePool(uint _CLV, uint _ETH) external returns(bool);\n\n    function redeemCollateral(address _account, uint _CLV, uint _ETH) external returns(bool);\n\n    // --- StabilityPool Functions ---\n    function provideToSP(uint _amount) external returns(bool);\n\n    function withdrawFromSP(uint _amount) external returns(bool);\n\n    function withdrawFromSPtoCDP(address _user, address _hint) external returns(bool);\n\n    function offset(uint _debt, uint _coll, uint CLVInPool) external payable returns(uint, uint);\n}"
    },
    "contracts/DeciMath.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\nlibrary DeciMath {\n    /* \n    DeciMath functions use the concept of a 'duint':\n    \n    A duint is a uint representation of an 18DP decimal number. The right-most \n    18 digits correspond to the mantissa, i.e. the digits after the decimal point. \n\n    Examples:\n       1000000000000000000   represents 1\n       5432100000000000000   represents 5.4321\n               34560000000   represents 0.00000003456\n     370000000000000000000   represents 370\n                         1   represents 1e-18\n\n     etc. \n    */\n\n    uint constant _1E18 = 10**18;\n    uint constant _1E17 = 10**17;\n    uint constant _5E17 = 5*(10**17);\n\n    // --- Accurate decimal math functions ---\n\n    /* Accurately calculate (x * y) / z. Converts all arguments to 'duints', performs \n    calculations, then converts the result back to uint before returning. */\n    // function accurateMulDiv(uint x, uint y, uint z) internal view returns (uint fraction) {\n    //     require( z!= 0, \"DeciMath: can not divide by zero\");\n    // // convert all uint to duint\n    //     uint x_duint = toDuint(x);\n    //     uint y_duint = toDuint(y);\n    //     uint z_duint = toDuint(z);\n\n    //     //  (x * y).  If y is guaranteed to be an integer (i.e. not duint) could use normalMul(x_duint, y) here to save gas.\n    //     uint prod_duint = decMul(x_duint, y_duint); \n    //     // (x* y) / z\n    //     uint res_duint = decDiv(prod_duint, z_duint);   \n\n    //     // convert result back to uint\n    //     uint result = fromDuint(res_duint);\n\n    //     return result;\n    // }\n\n    // Accurately divides one 'duint' by another. Returns a 'duint'\n    function decDiv(uint x, uint y) internal view returns (uint quotient) {\n        uint prod_x_1E18 = SafeMath.mul(x, _1E18);\n        uint half_y = SafeMath.div(y, 2);\n\n        quotient = SafeMath.div(SafeMath.add( prod_x_1E18, half_y), y);\n        return quotient;\n    }\n\n    // basic, no correction for floor div\n    // function decDiv(uint x, uint y) internal view returns (uint quotient) {\n    //     return SafeMath.div(SafeMath.mul(x, _1E18), y);\n    // }\n\n     // Accurately multiplies two 'duints'. Returns a 'duint'\n    function decMul(uint x, uint y) internal view returns (uint prod) {\n        uint prod_xy = SafeMath.mul(x, y);\n        prod = SafeMath.div(SafeMath.add(prod_xy, _5E17), _1E18 );\n\n        return prod;\n    }\n\n    // basic, no correction \n    //  function decMul(uint x, uint y) internal view returns (uint prod) {\n    //     return SafeMath.div(SafeMath.mul(x, y), _1E18);\n    // }\n\n    // Accurately divides one uint by another. Returns a 'duint'\n    function div_toDuint(uint x, uint y) internal view returns (uint quotient) {\n        uint x_duint = toDuint(x);\n        uint y_duint = toDuint(y);\n\n        quotient = decDiv(x_duint, y_duint);\n        return quotient;\n    }\n\n    // Accurately multiply one uint by a 'duint'. Returns a uint.\n    function mul_uintByDuint( uint x, uint y_duint) internal view returns (uint prod) {\n        uint x_duint = toDuint(x);\n\n        uint prod_duint = decMul(x_duint, y_duint);\n        uint prod = fromDuint(prod_duint);\n\n        return prod;\n    }\n\n    // function mul_uintByDuint_roundUp( uint x, uint y_duint) internal view returns (uint prod) {\n    //     uint x_duint = toDuint(x);\n\n    //     uint prod_duint = decMul(x_duint, y_duint);\n    //     uint prod = fromDuint_roundUp(prod_duint);\n\n    //     return prod;\n    // }\n\n     // --- Helpers. Convert to and from duints ---\n\n    function toDuint(uint integer) internal view returns(uint) {\n        return SafeMath.mul(integer, _1E18);\n    }\n\n    function fromDuint(uint duint) internal view returns(uint) {\n        // rounding: always round down\n        return SafeMath.div(duint, _1E18);\n    }\n\n     function fromDuint_roundUp(uint duint) internal view returns(uint) {\n        // rounding: common rounding.\n        uint integer;\n        integer =  SafeMath.div(duint, _1E18) + 1;  // round up\n        return integer;\n    }\n\n    function fromDuint_commonRounding(uint duint) internal view returns(uint) {\n        // rounding: common rounding. If first mantissa digit >=5 round up, else round down.\n        uint integer;\n        uint firstDecimalDigit = SafeMath.div(duint % _1E18, _1E17); // grab 18th digit from-right\n        \n        if (firstDecimalDigit >= 5 ){\n            integer =  SafeMath.div(duint, _1E18) + 1;  // round up\n            return integer;\n        } else if (firstDecimalDigit < 5 ) {\n            integer =  SafeMath.div(duint, _1E18); // round down\n            return integer;\n        }\n    }\n\n     // --- Normal Solidity multiplication and floor division ---\n    // function normalDiv(uint a, uint b) public view returns(uint) {\n    //     return SafeMath.div(a, b);\n    // }\n\n    // function normalMul(uint a, uint b) public view returns(uint) {\n    //     return SafeMath.mul(a, b);\n    // }  \n\n    // --- Normal min function ---\n    function getMin(uint a, uint b) internal view returns(uint) {\n        if (a <= b) return a;\n        else return b;\n    }\n}"
    },
    "contracts/CDPManager.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ICDPManager.sol\";\nimport \"./Interfaces/IPool.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/ICLVToken.sol\";\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Interfaces/ISortedCDPs.sol\";\nimport \"./Interfaces/IPoolManager.sol\";\nimport \"./DeciMath.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract CDPManager is Ownable, ICDPManager {\n    using SafeMath for uint;\n\n    uint constant public MCR = 1100000000000000000; // Minimal collateral ratio.\n    uint constant public  CCR = 1500000000000000000; // Critical system collateral ratio. If the total system collateral (TCR) falls below the CCR, Recovery Mode is triggered.\n    uint constant public MIN_COLL_IN_USD = 20000000000000000000;\n    enum Status { nonExistent, active, closed }\n    \n    // --- Events --- \n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event PoolManagerAddressChanged(address _newPoolManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event CLVTokenAddressChanged(address _newCLVTokenAddress);\n    event SortedCDPsAddressChanged(address _sortedCDPsAddress);\n\n    event CDPCreated(address indexed _user, uint arrayIndex);\n    event CDPUpdated(address indexed _user, uint _debt, uint _coll, uint stake);\n   \n    // --- Connected contract declarations ---\n\n    IBorrowerOperations borrowerOperations;\n    address public borrowerOperationsAddress;\n\n    IPoolManager poolManager;\n    address public poolManagerAddress;\n\n    IPool activePool;\n    address public activePoolAddress;\n\n    IPool defaultPool;\n    address public defaultPoolAddress;\n\n    ICLVToken CLV; \n    address public clvTokenAddress;\n\n    IPriceFeed priceFeed;\n    address public priceFeedAddress;\n\n    IStabilityPool stabilityPool;\n    address public stabilityPoolAddress;\n\n    // A doubly linked list of CDPs, sorted by their sorted by their collateral ratios\n    ISortedCDPs sortedCDPs;\n    address public sortedCDPsAddress;\n\n    // --- Modifiers ---\n\n    modifier onlyBorrowerOperations() {\n        require(_msgSender() == borrowerOperationsAddress, \"CDPManager: Caller is not the BorrowerOperations contract\");\n        _;\n    }\n\n    // --- Data structures ---\n\n    // Store the necessary data for a Collateralized Debt Position (CDP)\n    struct CDP {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint arrayIndex;\n    }\n\n    mapping (address => CDP) public CDPs;\n\n    uint public totalStakes; \n\n    // snapshot of the value of totalStakes immediately after the last liquidation\n    uint public totalStakesSnapshot;  \n\n    // snapshot of the total collateral in ActivePool and DefaultPool, immediately after the last liquidation.\n    uint public totalCollateralSnapshot;    \n\n    /* L_ETH and L_CLVDebt track the sums of accumulated liquidation rewards per unit staked. During it's lifetime, each stake earns:\n\n    An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    A CLVDebt gain  of ( stake * [L_CLVDebt - L_CLVDebt(0)] )\n    \n    Where L_ETH(0) and L_CLVDebt(0) are snapshots of L_ETH and L_CLVDebt for the active CDP taken at the instant the stake was made */\n    uint public L_ETH;     \n    uint public L_CLVDebt;    \n\n    // Map addresses with active CDPs to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;  \n\n    // Object containing the ETH and CLV snapshots for a given active CDP\n    struct RewardSnapshot { uint ETH; uint CLVDebt;}   \n\n    // Array of all active CDP addresses - used to compute “approx hint” for list insertion\n    address[] CDPOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint lastETHError_Redistribution;\n    uint lastCLVDebtError_Redistribution;\n\n    // --- Dependency setters --- \n\n    function setBorrowerOperations(address _borrowerOperationsAddress) public onlyOwner {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n    }\n    \n    function setPoolManager(address _poolManagerAddress) public onlyOwner {\n        poolManagerAddress = _poolManagerAddress;\n        poolManager = IPoolManager(_poolManagerAddress);\n        emit PoolManagerAddressChanged(_poolManagerAddress);\n    }\n\n    function setActivePool(address _activePoolAddress) public onlyOwner {\n        activePoolAddress = _activePoolAddress;\n        activePool = IPool(_activePoolAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n    }\n\n    function setDefaultPool(address _defaultPoolAddress) public onlyOwner {\n        defaultPoolAddress = _defaultPoolAddress;\n        defaultPool = IPool(_defaultPoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n    }\n\n    function setStabilityPool(address _stabilityPoolAddress) public onlyOwner {\n        stabilityPoolAddress = _stabilityPoolAddress;\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n    }\n\n    function setPriceFeed(address _priceFeedAddress) public onlyOwner {\n        priceFeedAddress = _priceFeedAddress;\n        priceFeed = IPriceFeed(priceFeedAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n    }\n\n    function setCLVToken(address _clvTokenAddress) public onlyOwner {\n        clvTokenAddress = _clvTokenAddress;\n        CLV = ICLVToken(_clvTokenAddress);\n        emit CLVTokenAddressChanged(_clvTokenAddress);\n    }\n\n    function setSortedCDPs(address _sortedCDPsAddress) public onlyOwner {\n        sortedCDPsAddress = _sortedCDPsAddress;\n        sortedCDPs = ISortedCDPs(_sortedCDPsAddress);\n        emit SortedCDPsAddressChanged(_sortedCDPsAddress);\n    }\n\n    // --- Getters ---\n    \n    function getCDPOwnersCount() public view returns(uint) {\n        return CDPOwners.length;\n    }\n    \n \n    // --- CDP Liquidation functions ---\n\n    // Closes the CDP of the specified user if its individual collateral ratio is lower than the minimum collateral ratio.\n    // TODO: Left public for initial testing. Make internal.\n    function liquidate(address _user) public returns (bool) {\n        uint price = priceFeed.getPrice();\n        uint ICR = getCurrentICR(_user, price);\n        \n        bool recoveryMode = checkRecoveryMode();\n\n        requireCDPisActive(_user);\n\n        if (recoveryMode == true) {\n            liquidateRecoveryMode(_user, ICR, price);\n        } else if (recoveryMode == false) {\n            liquidateNormalMode(_user, ICR);\n        }  \n    }\n   \n    function liquidateNormalMode(address _user, uint _ICR) internal returns (bool) {\n        // If ICR >= MCR, or is last trove, don't liquidate \n        if (_ICR >= MCR || CDPOwners.length <= 1) { return false; }\n       \n        // Get the CDP's entire debt and coll, including pending rewards from distributions\n        (uint entireCDPDebt, uint entireCDPColl) = getEntireDebtAndColl(_user);\n        _removeStake(_user); \n\n        uint CLVInPool = stabilityPool.getCLV();\n\n        // Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        if (CLVInPool > 0) {\n            (uint CLVDebtRemainder, uint ETHRemainder) = poolManager.offset(entireCDPDebt, entireCDPColl, CLVInPool);\n            redistributeDebtAndColl(CLVDebtRemainder, ETHRemainder);\n        } else {\n            redistributeDebtAndColl(entireCDPDebt, entireCDPColl);\n        }\n\n        _closeCDP(_user);\n        updateSystemSnapshots();\n        emit CDPUpdated(_user, 0, 0, 0);\n\n        return true;\n    }\n\n    function liquidateRecoveryMode(address _user, uint _ICR, uint _price) internal returns (bool) {\n        // If is last trove, don't liquidate\n        if (CDPOwners.length <= 1) { return false; }\n\n        // If ICR <= 100%, purely redistribute the CDP across all active CDPs\n        if (_ICR <= 1000000000000000000) {\n            (uint entireCDPDebt, uint entireCDPColl) = getEntireDebtAndColl(_user);\n            _removeStake(_user);\n            \n            redistributeDebtAndColl(entireCDPDebt, entireCDPColl);\n\n            _closeCDP(_user);\n            updateSystemSnapshots();\n\n        // if 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > 1000000000000000000) && (_ICR < MCR)) {\n            (uint entireCDPDebt, uint entireCDPColl) = getEntireDebtAndColl(_user);\n            _removeStake(_user);\n            \n            uint CLVInPool = stabilityPool.getCLV();\n\n            if (CLVInPool > 0) {\n                (uint CLVDebtRemainder, uint ETHRemainder) = poolManager.offset(entireCDPDebt, entireCDPColl, CLVInPool);\n                redistributeDebtAndColl(CLVDebtRemainder, ETHRemainder);\n            } else {\n                redistributeDebtAndColl(entireCDPDebt, entireCDPColl);\n            }\n    \n            _closeCDP(_user);\n            updateSystemSnapshots();\n\n        // If CDP has the lowest ICR and there is CLV in the Stability Pool, only offset it as much as possible (no redistribution)\n        } else if (_user == sortedCDPs.getLast()) {\n            \n            uint CLVInPool = stabilityPool.getCLV();\n            if (CLVInPool == 0) { return false; }\n\n            _applyPendingRewards(_user);\n            _removeStake(_user);\n\n            (uint CLVDebtRemainder, uint ETHRemainder) = poolManager.offset(CDPs[_user].debt, \n                                                                            CDPs[_user].coll, \n                                                                            CLVInPool);\n          \n            // Close the CDP and update snapshots if the CDP was completely offset against CLV in Stability Pool\n            if (CLVDebtRemainder == 0) {\n                _closeCDP(_user);\n                updateSystemSnapshots();\n            }\n\n            // If loan can not be entirely offset, leave the CDP active, with a reduced coll and debt, and corresponding new stake.\n            if (CLVDebtRemainder > 0) {\n                // Update system snapshots, excluding the reduced collateral that remains in the CDP\n                updateSystemSnapshots_excludeCollRemainder(ETHRemainder);\n                \n                // Give the loan a new reduced coll and debt, then update stake and totalStakes\n                CDPs[_user].coll = ETHRemainder;\n                CDPs[_user].debt = CLVDebtRemainder;\n                _updateStakeAndTotalStakes(_user);\n               \n                uint newICR = getCurrentICR(_user, _price);\n          \n                sortedCDPs.reInsert(_user, newICR, _price, _user, _user); \n            }\n        } \n        emit CDPUpdated(_user, \n                    CDPs[_user].debt, \n                    CDPs[_user].coll,\n                    CDPs[_user].stake\n                    );\n\n        return true;\n    }\n\n    // Closes a maximum number of n multiple under-collateralized CDPs, starting from the one with the lowest collateral ratio\n    function liquidateCDPs(uint n) public returns (bool) {  \n        uint price = priceFeed.getPrice();\n        bool recoveryModeAtStart = checkRecoveryMode();\n\n        if (recoveryModeAtStart == true) {\n            uint i;\n            bool backToNormalMode;\n\n            while (i < n) {\n                address user = sortedCDPs.getLast();\n                uint collRatio = getCurrentICR(user, price);\n                \n                // Attempt to close CDP\n                if (backToNormalMode == false) {\n                    liquidateRecoveryMode(user, collRatio, price);\n                    backToNormalMode = !checkRecoveryMode();\n                } \n                else {\n                    if (collRatio < MCR) {\n                        liquidateNormalMode(user, collRatio);\n                    } else break;  // break if the loop reaches a CDP with ICR >= MCR\n                } \n                // Break the loop if it reaches the first CDP in the sorted list \n                if (user == sortedCDPs.getFirst()) { break ;}\n                i++;\n            }\n            return true;\n\n        } else if (recoveryModeAtStart == false) {\n            uint i;\n            while (i < n) {\n                address user = sortedCDPs.getLast();\n                uint collRatio = getCurrentICR(user, price);\n\n                // Close CDPs if it is under-collateralized\n                if (collRatio < MCR) {\n                    liquidateNormalMode(user, collRatio);\n                } else break;  // break if the loop reaches a CDP with ICR >= MCR\n                \n                // Break the loop if it reaches the first CDP in the sorted list \n                if (user == sortedCDPs.getFirst()) { break ;}\n                i++;\n            }       \n        }\n        return true;\n    }\n\n    // Redeem as much collateral as possible from _cdpUser's CDP in exchange for CLV up to _maxCLVamount\n    function redeemCollateralFromCDP(\n        address _cdpUser,\n        uint _maxCLVamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (uint)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the CDP\n        uint CLVLot = DeciMath.getMin(_maxCLVamount, CDPs[_cdpUser].debt); \n        \n        // Pure division to integer\n        uint ETHLot = CLVLot.mul(1e18).div(_price);\n        \n        // Decrease the debt and collateral of the current CDP according to the lot and corresponding ETH to send\n        uint newDebt = (CDPs[_cdpUser].debt).sub(CLVLot);\n        uint newColl = (CDPs[_cdpUser].coll).sub(ETHLot);\n\n        if (newDebt == 0) {\n            // No debt left in the CDP, therefore new ICR must be \"infinite\".\n            // Passing zero as hint will cause sortedCDPs to descend the list from the head, which is the correct insert position.\n            sortedCDPs.reInsert(_cdpUser, 2**256 - 1, _price, address(0), address(0)); \n        } else {\n            uint newICR = computeICR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) return 0;\n\n            sortedCDPs.reInsert(_cdpUser, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n        }\n\n        CDPs[_cdpUser].debt = newDebt;\n        CDPs[_cdpUser].coll = newColl;\n        _updateStakeAndTotalStakes(_cdpUser);\n\n        // Burn the calculated lot of CLV and send the corresponding ETH to _msgSender()\n        poolManager.redeemCollateral(_msgSender(), CLVLot, ETHLot); \n\n        emit CDPUpdated(\n                        _cdpUser,\n                        newDebt,\n                        newColl,\n                        CDPs[_cdpUser].stake\n                        ); \n\n        return CLVLot;\n    }\n\n    function validFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedCDPs.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextCDP = sortedCDPs.getNext(_firstRedemptionHint);\n        return nextCDP == address(0) || getCurrentICR(nextCDP, _price) < MCR;\n    }\n\n    /* Send _CLVamount CLV to the system and redeem the corresponding amount of collateral from as many CDPs as are needed to fill the redemption\n     request.  Applies pending rewards to a CDP before reducing its debt and coll.\n\n    Note that if _amount is very large, this function can run out of gas. This can be easily avoided by splitting the total _amount\n    in appropriate chunks and calling the function multiple times.\n\n    All CDPs that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be\n    reinsterted at the top of the sortedCDPs list. If the last CDP does have some remaining debt, the reinsertion could be anywhere in the\n    list, therefore it requires a hint. A frontend should use getRedemptionHints() to calculate what the ICR of this CDP will be\n    after redemption, and pass a hint for its position in the sortedCDPs list along with the ICR value that the hint was found for.\n\n    If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    is very likely that the last (partially) redeemed CDP would end up with a different ICR than what the hint is for. In this case the\n    redemption will stop after the last completely redeemed CDP and the sender will keep the remaining CLV amount, which they can attempt\n    to redeem later.\n     */\n    function redeemCollateral(\n        uint _CLVamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        public returns (bool)\n    {\n        uint remainingCLV = _CLVamount;\n        uint price = priceFeed.getPrice();\n        address currentCDPuser;\n\n        if (validFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentCDPuser = _firstRedemptionHint;\n        } else {\n            currentCDPuser = sortedCDPs.getLast();\n\n            while (currentCDPuser != address(0) && getCurrentICR(currentCDPuser, price) < MCR) {\n                currentCDPuser = sortedCDPs.getPrev(currentCDPuser);\n            }\n        }\n\n        // Loop through the CDPs starting from the one with lowest collateral ratio until _amount of CLV is exchanged for collateral\n        while (currentCDPuser != address(0) && remainingCLV > 0) {\n            // Save the address of the CDP preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedCDPs.getPrev(currentCDPuser);\n\n            _applyPendingRewards(currentCDPuser);\n\n            uint CLVLot = redeemCollateralFromCDP(\n                currentCDPuser,\n                remainingCLV,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (CLVLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last CDP\n\n            remainingCLV = remainingCLV.sub(CLVLot);\n            currentCDPuser = nextUserToCheck;\n        }\n    }\n\n    // --- Helper functions ---\n\n    /* getRedemptionHints() - Helper function for redeemCollateral().\n     *\n     * Find the first and last CDPs that will modified by calling redeemCollateral() with the same _CLVamount and _price,\n     * and return the address of the first one and the final ICR of the last one.\n     */\n    function getRedemptionHints(uint _CLVamount, uint _price)\n        public\n        view\n        returns (address firstRedemptionHint, uint partialRedemptionHintICR)\n    {\n        uint remainingCLV = _CLVamount;\n        address currentCDPuser = sortedCDPs.getLast();\n\n        while (currentCDPuser != address(0) && getCurrentICR(currentCDPuser, _price) < MCR) {\n            currentCDPuser = sortedCDPs.getPrev(currentCDPuser);\n        }\n\n        firstRedemptionHint = currentCDPuser;\n\n        while (currentCDPuser != address(0) && remainingCLV > 0) {\n            uint CLVDebt = CDPs[currentCDPuser].debt.add(computePendingCLVDebtReward(currentCDPuser));\n\n            if (CLVDebt > remainingCLV) {\n                uint ETH = CDPs[currentCDPuser].coll.add(computePendingETHReward(currentCDPuser));\n                uint newDebt = CLVDebt.sub(remainingCLV);\n\n                uint newColl = ETH.sub(remainingCLV.mul(1e18).div(_price));\n\n                partialRedemptionHintICR = computeICR(newColl, newDebt, _price);\n\n                break;\n            } else {\n                remainingCLV = remainingCLV.sub(CLVDebt);\n            }\n\n            currentCDPuser = sortedCDPs.getPrev(currentCDPuser);\n        }\n    }\n\n     /* getApproxHint() - return address of a CDP that is, on average, (length / numTrials) positions away in the \n    sortedCDPs list from the correct insert position of the CDP to be inserted. \n    \n    Note: The output address is worst-case O(n) positions away from the correct insert position, however, the function \n    is probabilistic. Input can be tuned to guarantee results to a high degree of confidence, e.g:\n\n    Submitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the ouput address will \n    be <= sqrt(length) positions away from the correct insert position.\n   \n    Note on the use of block.timestamp for random number generation: it is known to be gameable by miners. However, no value \n    transmission depends on getApproxHint() - it is only used to generate hints for efficient list traversal. In this case, \n    there is no profitable exploit.\n    */\n    function getApproxHint(uint CR, uint numTrials) public view returns(address) {\n        require (CDPOwners.length >= 1, \"CDPManager: sortedList must not be empty\");\n        uint price = priceFeed.getPrice();\n        address hintAddress = sortedCDPs.getLast();\n        uint closestICR = getCurrentICR(hintAddress, price);\n        uint diff = getAbsoluteDifference(CR, closestICR);\n        uint i = 1;\n\n        while (i < numTrials) {\n            uint arrayIndex = getRandomArrayIndex(block.timestamp.add(i), CDPOwners.length);\n            address currentAddress = CDPOwners[arrayIndex];\n            uint currentICR = getCurrentICR(currentAddress, price);\n\n            // check if abs(current - CR) > abs(closest - CR), and update closest if current is closer\n            uint currentDiff = getAbsoluteDifference(currentICR, CR);\n\n            if (currentDiff < diff) {\n                closestICR = currentICR;\n                diff = currentDiff;\n                hintAddress = currentAddress;\n            }\n            i++;\n        }\n    return hintAddress;\n}\n\n    function getAbsoluteDifference(uint a, uint b) internal view returns(uint) {\n        if (a > b) {\n            return a.sub(b);\n        } else if (a < b) {\n            return b.sub(a);\n        }\n    }\n\n    // Convert input to pseudo-random uint in range [0, arrayLength - 1]\n    function getRandomArrayIndex(uint input, uint _arrayLength) internal view returns(uint) {\n        uint randomIndex = uint256(keccak256(abi.encodePacked(input))) % (_arrayLength);\n        return randomIndex;\n   }\n\n    // Return the current collateral ratio (ICR) of a given CDP. Takes pending coll/debt rewards into account.\n    function getCurrentICR(address _user, uint _price) public view returns(uint) {\n        uint pendingETHReward = computePendingETHReward(_user); \n        uint pendingCLVDebtReward = computePendingCLVDebtReward(_user); \n        \n        uint currentETH = CDPs[_user].coll.add(pendingETHReward); \n        uint currentCLVDebt = CDPs[_user].debt.add(pendingCLVDebtReward); \n       \n        uint ICR = computeICR(currentETH, currentCLVDebt, _price);  \n        return ICR;\n    }\n\n    function computeICR(uint _coll, uint _debt, uint _price) view internal returns(uint) {\n        // Check if the total debt is higher than 0, to avoid division by 0\n        if (_debt > 0) {\n\n            // Pure division to decimal\n            uint newCollRatio = _coll.mul(_price).div(_debt);\n\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the CDP has a debt of 0\n        else {\n            return 2**256 - 1; \n        }\n    }\n\n    \n    function applyPendingRewards(address _user) external onlyBorrowerOperations returns(bool) {\n        return _applyPendingRewards(_user);\n    }\n\n    // Add the user's coll and debt rewards earned from liquidations, to their CDP\n    function _applyPendingRewards(address _user) internal returns(bool) {\n        if (hasPendingRewards(_user) == false) { return false; }\n        \n        requireCDPisActive(_user);\n\n        // Compute pending rewards\n        uint pendingETHReward = computePendingETHReward(_user); \n        uint pendingCLVDebtReward = computePendingCLVDebtReward(_user);  \n\n        // Apply pending rewards\n        CDPs[_user].coll = CDPs[_user].coll.add(pendingETHReward);  \n        CDPs[_user].debt = CDPs[_user].debt.add(pendingCLVDebtReward); \n\n        // Tell PM to transfer from DefaultPool to ActivePool when user claims rewards\n        poolManager.moveDistributionRewardsToActivePool(pendingCLVDebtReward, pendingETHReward); \n\n        _updateRewardSnapshots(_user); // 5259 (no rewards)\n        return true;\n    }\n\n    // Update user's snapshots of L_ETH and L_CLVDebt to reflect the current values\n\n    function updateRewardSnapshots(address _user) external onlyBorrowerOperations returns(bool) {\n       return  _updateRewardSnapshots(_user);\n    }\n\n    function _updateRewardSnapshots(address _user) internal returns(bool) {\n        rewardSnapshots[_user].ETH = L_ETH; \n        rewardSnapshots[_user].CLVDebt = L_CLVDebt; \n        return true;\n    }\n    \n    // Get the user's pending accumulated ETH reward, earned by its stake\n    function computePendingETHReward(address _user) internal view returns(uint) {\n        uint snapshotETH = rewardSnapshots[_user].ETH; \n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH); \n        \n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n       \n        uint stake = CDPs[_user].stake;\n        \n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the user's pending accumulated CLV reward, earned by its stake\n    function computePendingCLVDebtReward(address _user) internal view returns(uint) {\n        uint snapshotCLVDebt = rewardSnapshots[_user].CLVDebt;  \n        uint rewardPerUnitStaked = L_CLVDebt.sub(snapshotCLVDebt); \n       \n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n       \n        uint stake =  CDPs[_user].stake; \n      \n        uint pendingCLVDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n     \n        return pendingCLVDebtReward;\n    }\n\n    function hasPendingRewards(address _user) public view returns (bool) {\n        // A CDP has pending rewards if the current reward sum differs from the CDP's snapshot\n        return (rewardSnapshots[_user].ETH != L_ETH);\n    }\n\n    /* Computes the CDPs entire debt and coll, including distribution pending rewards. Transfers any rewards \n    from Default Pool to Active Pool. */ \n    function getEntireDebtAndColl(address _user) \n    internal \n    returns (uint debt, uint coll)\n    {\n        debt = CDPs[_user].debt;\n        coll = CDPs[_user].coll;\n\n        if (hasPendingRewards(_user)) {\n            uint pendingCLVDebtReward = computePendingCLVDebtReward(_user);\n            uint pendingETHReward = computePendingETHReward(_user);\n\n            debt = debt.add(pendingCLVDebtReward);\n            coll = coll.add(pendingETHReward);\n\n            poolManager.moveDistributionRewardsToActivePool(pendingCLVDebtReward, pendingETHReward); \n        }\n\n        return (debt, coll);\n    }\n\n    function removeStake(address _user) external onlyBorrowerOperations returns (bool) {\n        return _removeStake(_user);\n    }\n\n    // Remove use's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _user) internal returns (bool) {\n        uint stake = CDPs[_user].stake;\n        totalStakes = totalStakes.sub(stake);\n        CDPs[_user].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _user) external onlyBorrowerOperations returns (uint) {\n        return _updateStakeAndTotalStakes(_user);\n    }\n\n    // Update user's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _user) internal returns (uint) {\n        uint newStake = computeNewStake(CDPs[_user].coll); \n        uint oldStake = CDPs[_user].stake;\n        CDPs[_user].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    function computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n     return stake;\n    }\n\n    function redistributeDebtAndColl(uint _debt, uint _coll) internal returns (bool) {\n        if (_debt == 0) { return false; }\n        \n        if (totalStakes > 0) {\n            // Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            \n            // Division with correction\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint CLVDebtNumerator = _debt.mul(1e18).add(lastCLVDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint CLVDebtRewardPerUnitStaked = CLVDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastCLVDebtError_Redistribution = CLVDebtNumerator.sub(CLVDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_CLVDebt = L_CLVDebt.add(CLVDebtRewardPerUnitStaked);\n        }\n        // Transfer coll and debt from ActivePool to DefaultPool\n        poolManager.liquidate(_debt, _coll);\n    }\n\n    function closeCDP(address _user) external onlyBorrowerOperations returns (bool) {\n        return _closeCDP(_user);\n    }\n\n    function _closeCDP(address _user) internal returns (bool) {\n        CDPs[_user].status = Status.closed;\n        CDPs[_user].coll = 0;\n        CDPs[_user].debt = 0;\n        \n        rewardSnapshots[_user].ETH = 0;\n        rewardSnapshots[_user].CLVDebt = 0;\n \n        sortedCDPs.remove(_user);\n        removeCDPOwner(_user);\n       \n        return true;\n    }\n\n    // Update the snapshots of system stakes & system collateral\n    function updateSystemSnapshots() internal returns (bool) {\n        totalStakesSnapshot = totalStakes;\n\n        /* The total collateral snapshot is the sum of all active collateral and all pending rewards\n       (ActivePool ETH + DefaultPool ETH), immediately after the liquidation occurs. */\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.add(liquidatedColl);\n\n        return true;\n    }\n\n    // Updates snapshots of system stakes and system collateral, excluding a given collateral remainder from the calculation\n    function updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal returns (bool) {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n\n        return true;\n    }\n  \n    // Push the owner's address to the CDP owners list, and record the corresponding array index on the CDP struct\n    function addCDPOwnerToArray(address _user) external onlyBorrowerOperations returns (uint index) {\n        index = CDPOwners.push(_user).sub(1);\n        CDPs[_user].arrayIndex = index;\n\n        return index;\n    }\n\n     /* Remove a CDP owner from the CDPOwners array, not preserving order. Removing owner 'B' does the following: \n    [A B C D E] => [A E C D], and updates E's CDP struct to point to its new array index. */\n    function removeCDPOwner(address _user) internal returns(bool) {\n        require(CDPs[_user].status == Status.closed, \"CDPManager: CDP is still active\");\n\n        uint index = CDPs[_user].arrayIndex;   \n        uint length = CDPOwners.length;\n        uint idxLast = length.sub(1);\n\n        assert(length >= 1);  // Encapsulating function should only be reachable when there are >0 troves in the system\n        assert(index <= idxLast); \n\n        address addressToMove = CDPOwners[idxLast];\n       \n        CDPOwners[index] = addressToMove;   \n        CDPs[addressToMove].arrayIndex = index;   \n        CDPOwners.length--;  \n    }\n  \n    function checkRecoveryMode() public view returns (bool){\n        uint price = priceFeed.getPrice();\n\n        uint activeColl = activePool.getETH();\n        uint activeDebt = activePool.getCLV();\n        uint liquidatedColl = defaultPool.getETH();\n        uint closedDebt = defaultPool.getCLV();\n\n        uint totalCollateral = activeColl.add(liquidatedColl);\n        uint totalDebt = activeDebt.add(closedDebt); \n\n        uint TCR = computeICR(totalCollateral, totalDebt, price); \n        \n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function requireCDPisActive(address _user) internal view {\n        require(CDPs[_user].status == Status.active, \"CDPManager: CDP does not exist or is closed\");\n    }\n\n    // --- Trove property getters ---\n\n    function getCDPStatus(address _user) external view returns (uint) {\n        return uint(CDPs[_user].status);\n    }\n\n    function getCDPStake(address _user) external view returns (uint) {\n        return CDPs[_user].stake;\n    }\n\n    function getCDPDebt(address _user) external view returns (uint) {\n        return CDPs[_user].debt;\n    }\n\n    function getCDPColl(address _user) external view returns (uint) {\n        return CDPs[_user].coll;\n    }\n\n    // --- Trove property setters --- \n\n    function setCDPStatus(address _user, uint num) external onlyBorrowerOperations {\n        CDPs[_user].status = Status(num);\n    }\n\n    function increaseCDPColl(address _user, uint _collIncrease) external onlyBorrowerOperations returns (uint) {\n        uint newColl = CDPs[_user].coll.add(_collIncrease);\n        CDPs[_user].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseCDPColl(address _user, uint _collDecrease) external onlyBorrowerOperations returns (uint) {\n        uint newColl = CDPs[_user].coll.sub(_collDecrease);\n        CDPs[_user].coll = newColl;\n        return newColl;\n    }\n\n    function increaseCDPDebt(address _user, uint _debtIncrease) external onlyBorrowerOperations returns (uint) {\n        uint newDebt = CDPs[_user].debt.add(_debtIncrease);\n        CDPs[_user].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseCDPDebt(address _user, uint _debtDecrease) external onlyBorrowerOperations returns (uint) {\n        uint newDebt = CDPs[_user].debt.sub(_debtDecrease);\n        CDPs[_user].debt = newDebt;\n        return newDebt;\n    }\n}"
    },
    "contracts/Interfaces/IStabilityPool.sol": {
      "content": "pragma solidity ^0.5.15;\n\ninterface IStabilityPool {\n    // --- Events ---\n    event ETHBalanceUpdated(uint _newBalance);\n\n    event CLVBalanceUpdated(uint _newBalance);\n\n    event PoolManagerAddressChanged(address _newAddress);\n\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n\n    event EtherSent(address _to, uint _amount);\n\n    // --- Functions ---\n    function getETH() external view returns(uint);\n    \n    function getCLV() external view returns(uint);\n\n    function setPoolManagerAddress(address _poolManagerAddress) external;\n\n    function setActivePoolAddress(address _activePoolAddress) external;\n\n    function setDefaultPoolAddress(address _defaultPoolAddress) external;\n    \n    function sendETH(address _account, uint _amount) external returns(bool);\n\n    function increaseCLV(uint _amount) external;\n\n    function decreaseCLV(uint _amount) external;\n\n    function getRawETHBalance() external view returns(uint);\n}"
    },
    "contracts/Interfaces/ICLVToken.sol": {
      "content": "pragma solidity ^0.5.15;\n\ninterface ICLVToken { \n    // --- Events ---\n    event PoolManagerAddressChanged( address _newPoolManagerAddress);\n\n    event CLVTokenBalanceUpdated(address _user, uint _amount);\n\n    // --- Functions ---\n    function setPoolManagerAddress(address _poolManagerAddress) external;\n\n    function mint(address _account, uint256 _amount) external returns(bool);\n\n    function burn(address _account, uint256 _amount) external returns(bool);\n\n    function sendToPool(address _sender,  address poolAddress, uint256 _amount) external returns(bool);\n\n    function returnFromPool(address poolAddress, address user, uint256 _amount ) external returns(bool);\n\n    function totalSupply() external view returns(uint256);\n\n    function balanceOf(address account) external view returns(uint256);\n\n    function transfer(address recipient, uint256 amount) external returns(bool);\n\n    function allowance(address owner, address spender) external view returns(uint256);\n\n    function approve(address spender, uint256 amount) external returns(bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns(bool);\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns(bool);\n}"
    },
    "contracts/CLVToken.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./Interfaces/ICLVToken.sol\";\nimport \"./CLVTokenData.sol\";\nimport \"./Dependencies/ERC20.sol\";\nimport \"./Dependencies/IERC20.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract CLVToken is IERC20, ICLVToken, Ownable {\n    using SafeMath for uint256;\n    \n    event PoolManagerAddressChanged( address _newPoolManagerAddress);\n    event CLVTokenBalanceUpdated(address _user, uint _amount);\n\n    address public poolManagerAddress;\n\n    uint256 public _totalSupply;\n\n    CLVTokenData clvTokenData;\n    address public tokenDataAddress;\n\n    constructor() public {\n        clvTokenData = new CLVTokenData();\n        tokenDataAddress = address(clvTokenData);\n    }    \n\n     modifier onlyPoolManager {\n        require(_msgSender() == poolManagerAddress, \"CLVToken: Caller is not the PoolManager\");\n        _;\n    }\n\n    function setPoolManagerAddress(address _poolManagerAddress) public onlyOwner {\n        poolManagerAddress =  _poolManagerAddress;\n        emit PoolManagerAddressChanged(_poolManagerAddress);\n    }\n\n    function mint(address _account, uint256 _amount) public onlyPoolManager returns (bool) {\n        _mint(_account, _amount); \n        return true;\n    }\n    \n    function burn(address _account, uint256 _amount) public onlyPoolManager returns (bool) {\n        _burn(_account, _amount); \n        return true;\n    }\n    \n    function sendToPool(address _sender,  address poolAddress, uint256 _amount) public onlyPoolManager returns (bool) {\n        _transfer(_sender, poolAddress, _amount);\n        return true;\n    }\n    \n    function returnFromPool(address poolAddress, address user, uint256 _amount ) public onlyPoolManager returns (bool) {\n        _transfer(poolAddress, user, _amount);\n        return true;\n    }\n\n   // --- OPENZEPPELIN ERC20 FUNCTIONALITY ---\n\n   /**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\n   \n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        uint balance = clvTokenData.getBalance(account); \n        return balance; \n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return clvTokenData.getAllowance(owner, spender);\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        uint newAllowance = clvTokenData.getAllowance(sender, _msgSender()).sub(amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), newAllowance);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        uint newAllowance = clvTokenData.getAllowance(_msgSender(),spender).add(addedValue);\n        _approve(_msgSender(), spender, newAllowance);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        uint newAllowance = clvTokenData.getAllowance(_msgSender(), spender).sub(subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, newAllowance);\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        clvTokenData.subFromBalance(sender, amount);\n        clvTokenData.addToBalance(recipient, amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        clvTokenData.addToBalance(account, amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");  \n        clvTokenData.subFromBalance(account, amount);  \n        \n        _totalSupply = _totalSupply.sub(amount);  \n\n        emit Transfer(account, address(0), amount); \n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        clvTokenData.setAllowance(owner, spender, amount);\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        uint newAllowance = clvTokenData.getAllowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n        _approve(account, _msgSender(), newAllowance);\n    }\n}\n"
    },
    "contracts/CLVTokenData.sol": {
      "content": "pragma solidity ^0.5.15;\n\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\n// Stores the CLV user data: token balances and spending allowances.\n// Functions are setters, addition and subtraction. Actual token logic resides in CLVToken.sol\n\ncontract CLVTokenData is Ownable {\n    using SafeMath for uint;\n\n    // User data for CLV token\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowances;\n\n    // CLV token logic contract address\n    address clvTokenAddress;\n\n    constructor() public {\n        clvTokenAddress = _msgSender();\n    }\n\n    modifier onlyCLVTokenAddress {\n        require(_msgSender() == clvTokenAddress, \"CLVTokenData: Caller is not the CLVToken contract\");\n        _;\n    }\n\n    // --- Balance functions --- \n\n    function getBalance(address account) external view returns(uint) { \n        return balances[account];\n    }\n\n    function setBalance(address account, uint256 newBalance) external  onlyCLVTokenAddress {\n        balances[account] = newBalance;\n    }\n\n    function addToBalance(address account, uint256 value) external onlyCLVTokenAddress {\n        balances[account] = balances[account].add(value);\n    }\n\n    function subFromBalance(address account, uint256 value) external onlyCLVTokenAddress {\n        balances[account] = balances[account].sub(value, 'ERC20: subtracted amount exceeds balance'); \n    }\n\n    // --- Allowance functions ---\n    \n    function getAllowance(address owner, address spender) external view returns(uint) {\n        return allowances[owner][spender];\n    }\n\n    function setAllowance(address owner, address spender, uint256 allowance) external onlyCLVTokenAddress {\n        allowances[owner][spender] = allowance;\n    }\n}"
    },
    "contracts/Dependencies/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./Context.sol\";\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n"
    },
    "contracts/Dependencies/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/DefaultPool.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport './Interfaces/IPool.sol';\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract DefaultPool is Ownable, IPool {\n    using SafeMath for uint256;\n\n    address public poolManagerAddress;\n    address public stabilityPoolAddress;\n    address public activePoolAddress;\n    uint256 public ETH;  // deposited ether tracker\n    uint256 public CLV;  // total outstanding CDP debt\n\n    constructor() public {}\n\n    // --- Contract setters ---\n\n    function setPoolManagerAddress(address _poolManagerAddress) public onlyOwner {\n        poolManagerAddress = _poolManagerAddress;\n        emit PoolManagerAddressChanged(poolManagerAddress);\n    }\n\n    function setActivePoolAddress(address _activePoolAddress) public onlyOwner {\n        activePoolAddress = _activePoolAddress;\n        emit ActivePoolAddressChanged(activePoolAddress);\n    }\n\n    function setStabilityPoolAddress(address _stabilityPoolAddress) public onlyOwner {\n        stabilityPoolAddress = _stabilityPoolAddress;\n        emit StabilityPoolAddressChanged(stabilityPoolAddress);\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getETH() public view returns(uint) {\n        return ETH;\n    }\n\n    function getCLV() public view returns(uint) {\n        return CLV;\n    }\n\n    // --- Pool functionality ---\n\n    function sendETH(address _account, uint _amount) public onlyPoolManager returns(bool) {\n        ETH = ETH.sub(_amount); \n        (bool success, ) = _account.call.value(_amount)(\"\");  // use call.value()('') as per Consensys latest advice \n        assert(success == true);   \n     \n        emit EtherSent(_account, _amount);  \n        return success;\n    }\n\n    function increaseCLV(uint _amount) public onlyPoolManager () {\n        CLV  = CLV.add(_amount);\n    }\n\n    function decreaseCLV(uint _amount) public onlyPoolManager () {\n        CLV = CLV.sub(_amount); \n    }\n\n    /* Returns the raw ether balance at DefaultPool address.  \n    Not necessarily equal to the ETH state variable - ether can be forcibly sent to contracts. */\n    function getRawETHBalance() public view returns(uint) {\n        return address(this).balance;\n    }\n\n    modifier onlyPoolManager {\n        require(_msgSender() == poolManagerAddress, \"DefaultPool:  Caller is not the PoolManager\");\n        _;\n    }\n\n    modifier onlyPoolManagerOrPool {\n        require(\n            _msgSender() == poolManagerAddress || \n            _msgSender() == stabilityPoolAddress || \n            _msgSender() == activePoolAddress, \n            \"DefaultPool: Caller is neither the PoolManager nor a Pool\");\n        _;\n    }\n\n    function () external payable onlyPoolManagerOrPool {\n        ETH = ETH.add(msg.value);\n    }\n}\n"
    },
    "contracts/FunctionCaller.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport './Interfaces/ICDPManager.sol';\nimport './Interfaces/ISortedCDPs.sol';\nimport './Interfaces/IPriceFeed.sol';\nimport './DeciMath.sol';\n\n// Proxy contract - used for calculating gas of read-only functions in gas calculation scripts.  Not part of the application.\ncontract FunctionCaller {\n\n    uint number = 1;\n\n    ICDPManager cdpManager;\n    address cdpManagerAddress;\n\n    ISortedCDPs sortedCDPs;\n    address sortedCDPsAddress;\n\n    IPriceFeed priceFeed;\n    address priceFeedAddress;\n\n    // --- Dependency setters ---\n\n    function setCDPManagerAddress(address _cdpManagerAddress) public {\n        cdpManagerAddress = _cdpManagerAddress;\n        cdpManager = ICDPManager(_cdpManagerAddress);\n    }\n    \n    function setSortedCDPsAddress(address _sortedCDPsAddress) public {\n        cdpManagerAddress = _sortedCDPsAddress;\n        sortedCDPs = ISortedCDPs(_sortedCDPsAddress);\n    }\n\n     function setPriceFeedAddress(address _priceFeedAddress) public {\n        priceFeedAddress = _priceFeedAddress;\n        priceFeed = IPriceFeed(_priceFeedAddress);\n    }\n\n    // --- PriceFeed functions ---\n\n     function priceFeed_getPrice() public returns(uint) {\n        return priceFeed.getPrice();\n    }\n\n    // --- CDPManager functions ---\n    function cdpManager_getCurrentICR (address _address, uint _price) public returns(uint) {\n        return cdpManager.getCurrentICR(_address, _price);  \n    }\n\n    function cdpManager_getApproxHint (uint _CR, uint _numTrials) public returns(address) {\n        return cdpManager.getApproxHint(_CR, _numTrials);\n    }\n\n    // --- SortedCDPs functions ---\n\n    function sortedCDPs_findInsertPosition(uint _ICR, uint _price, address _prevId, address _nextId) public returns(address, address) {\n        return sortedCDPs.findInsertPosition(_ICR, _price, _prevId, _nextId);\n    }\n\n    // --- DeciMath public functions ---\n\n    // function decimath_accurateMulDiv(uint x, uint y, uint z) public returns(uint fraction) {\n    //     return DeciMath.accurateMulDiv(x ,y, z);\n    // }\n\n    function getMin(uint a, uint b) public view returns(uint) {\n        return DeciMath.getMin(a, b);\n    }\n\n    function decimath_decMul(uint x, uint y) public returns (uint prod) {\n        return DeciMath.decMul(x, y);\n    }\n   \n    function decimath_decDiv(uint x, uint y) public returns (uint quotient) {\n        return DeciMath.decDiv(x, y);\n    }\n\n    function decimath_div_toDuint(uint x, uint y) public returns (uint quotient) {\n        // console.log(\"0. gas left: %s\", gasleft());\n        uint quotient = DeciMath.div_toDuint(x, y); // 1097 gas\n        // console.log(\"1. gas left: %s\", gasleft());\n        return quotient;\n    }\n\n    function decimath_mul_uintByDuint( uint x, uint y_duint)public returns (uint prod) {\n        //  console.log(\"0. gas left: %s\", gasleft());\n        uint z = DeciMath.mul_uintByDuint(x, y_duint);  // 967 gas\n        //  console.log(\"1. gas left: %s\", gasleft());\n        return z;\n    }\n    \n    //  ---- Funcs for checking write-to-storage costs ---\n\n    function repeatedlySetVal (uint n) public returns (uint, uint) {\n        for (uint i = 2; i < n + 2; i ++) {\n            number = i;\n        }\n    }\n    \n    function repeatedlySetValThenClearIt (uint n) public returns (uint, uint) {\n        for (uint i = 2; i < n + 2; i ++) {\n            number = i;\n        }\n        number = 0;\n    }\n\n   // --- gas costs: Internal vs raw code ---\n\n   function internalStorageCheck () internal returns (bool) {\n       return (number == 42);\n   }\n\n   // Check storage by way of an internal functional call\n   function callInternalStorageCheck () public returns (bool) {\n       return internalStorageCheck();\n   }\n\n    // Check storage directly\n   function rawStorageCheck () public returns (bool) {\n       return (number == 42);\n   }\n}"
    },
    "contracts/Interfaces/AggregatorInterface.sol": {
      "content": "pragma solidity ^0.5.15;\n\ninterface AggregatorInterface {\n    event AnswerUpdated(int256 indexed current,  uint256 indexed roundId, uint256 timestamp);\n\n    event NewRound(uint256 indexed roundId, address indexed startedBy);\n\n    function latestAnswer() external view returns (int256);\n\n    function latestTimestamp() external view returns (uint256);\n\n    function latestRound() external view returns (uint256);\n\n    function getAnswer(uint256 roundId) external view returns (int256);\n\n    function getTimestamp(uint256 roundId) external view returns (uint256); \n}"
    },
    "contracts/Interfaces/IDeployedAggregator.sol": {
      "content": "pragma solidity ^0.5.15;\n\n/* Interface for the mainnet deployed Chainlink aggregator reference contract. Differs from the aggregator interface\nin the Chainlink npm package */\ninterface IDeployedAggregator {\n  function latestCompletedAnswer (  ) external view returns ( uint256 );\n  function currentAnswer (  ) external view returns ( int256 );\n  function updatedHeight (  ) external view returns ( uint256 );\n}"
    },
    "contracts/Migrations.sol": {
      "content": "pragma solidity ^0.5.16;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"
    },
    "contracts/MultiCDPGetter.sol": {
      "content": "pragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"./CDPManager.sol\";\nimport \"./SortedCDPs.sol\";\n\ncontract MultiCDPGetter {\n    struct CombinedCDPData {\n        address owner;\n\n        uint debt;\n        uint coll;\n        uint stake;\n\n        uint snapshotETH;\n        uint snapshotCLVDebt;\n    }\n\n    CDPManager cdpManager; // XXX CDPs missing from ICDPManager?\n    ISortedCDPs sortedCDPs;\n\n    constructor(CDPManager _cdpManager, ISortedCDPs _sortedCDPs) public {\n        cdpManager = _cdpManager;\n        sortedCDPs = _sortedCDPs;\n    }\n\n    function min(uint a, uint b) internal pure returns (uint) {\n        return a < b ? a : b;\n    }\n\n    function getMultipleSortedCDPs(int _startIdx, uint _count)\n        external view returns (CombinedCDPData[] memory _cdps)\n    {\n        uint startIdx;\n        bool descend;\n\n        if (_startIdx >= 0) {\n            startIdx = uint(_startIdx);\n            descend = true;\n        } else {\n            startIdx = uint(-(_startIdx + 1));\n            descend = false;\n        }\n\n        uint sortedCDPsSize = sortedCDPs.getSize();\n\n        if (startIdx >= sortedCDPsSize) {\n            _cdps = new CombinedCDPData[](0);\n        } else {\n            uint maxCount = sortedCDPsSize - startIdx;\n\n            if (_count > maxCount) {\n                _count = maxCount;\n            }\n\n            if (descend) {\n                _cdps = getMultipleSortedCDPsFromHead(startIdx, _count);\n            } else {\n                _cdps = getMultipleSortedCDPsFromTail(startIdx, _count);\n            }\n        }\n    }\n\n    function getMultipleSortedCDPsFromHead(uint _startIdx, uint _count)\n        internal view returns (CombinedCDPData[] memory _cdps)\n    {\n        address currentCDPowner = sortedCDPs.getFirst();\n\n        for (uint idx = 0; idx < _startIdx; ++idx) {\n            currentCDPowner = sortedCDPs.getNext(currentCDPowner);\n        }\n\n        _cdps = new CombinedCDPData[](_count);\n\n        for (uint idx = 0; idx < _count; ++idx) {\n            _cdps[idx].owner = currentCDPowner;\n            (\n                _cdps[idx].debt,\n                _cdps[idx].coll,\n                _cdps[idx].stake,\n                /* status */,\n                /* arrayIndex */\n            ) = cdpManager.CDPs(currentCDPowner);\n            (\n                _cdps[idx].snapshotETH,\n                _cdps[idx].snapshotCLVDebt\n            ) = cdpManager.rewardSnapshots(currentCDPowner);\n\n            currentCDPowner = sortedCDPs.getNext(currentCDPowner);\n        }\n    }\n\n    function getMultipleSortedCDPsFromTail(uint _startIdx, uint _count)\n        internal view returns (CombinedCDPData[] memory _cdps)\n    {\n        address currentCDPowner = sortedCDPs.getLast();\n\n        for (uint idx = 0; idx < _startIdx; ++idx) {\n            currentCDPowner = sortedCDPs.getPrev(currentCDPowner);\n        }\n\n        _cdps = new CombinedCDPData[](_count);\n\n        for (uint idx = 0; idx < _count; ++idx) {\n            _cdps[idx].owner = currentCDPowner;\n            (\n                _cdps[idx].debt,\n                _cdps[idx].coll,\n                _cdps[idx].stake,\n                /* status */,\n                /* arrayIndex */\n            ) = cdpManager.CDPs(currentCDPowner);\n            (\n                _cdps[idx].snapshotETH,\n                _cdps[idx].snapshotCLVDebt\n            ) = cdpManager.rewardSnapshots(currentCDPowner);\n\n            currentCDPowner = sortedCDPs.getPrev(currentCDPowner);\n        }\n    }\n}\n"
    },
    "contracts/SortedCDPs.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./Interfaces/ISortedCDPs.sol\";\nimport \"./Interfaces/ICDPManager.sol\";\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\n/* \nA sorted doubly linked list with nodes sorted in descending order, based on current ICRs of active CDPs. \nOptionally accepts insert position hints.\n\nICRs are computed dynamically at runtime, and not stored on the Node. This is because ICRs of active CDPs \nchange dynamically as liquidation events occur.\n\nThe list relies on the fact that liquidation events preserve ordering: a liquidation decreases the ICRs of all active CDPs, \nbut maintains their order. A node inserted based on current ICR will maintain the correct position, \nrelative to it's peers, as rewards accumulate. Thus, Nodes remain sorted by current ICR.\n\nNodes need only be re-inserted upon a CDP operation - when the owner adds or removes collateral or debt.\n\nThe list is a modification of the following audited SortedDoublyLinkedList:\nhttps://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\n\nIn our variant, keys have been removed, and all ICR checks in functions now compare an ICR argument to the current ICR, \ncalculated at runtime. Data is stored in the 'data' state variable.\n*/\ncontract SortedCDPs is Ownable, ISortedCDPs {\n    using SafeMath for uint256;\n\n    event CDPManagerAddressChanged(address _newCDPlManagerAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n\n    IBorrowerOperations borrowerOperations;\n    address public borrowerOperationsAddress;\n\n    ICDPManager cdpManager;\n    address public CDPManagerAddress;\n\n    // Information for a node in the list\n    struct Node {\n        bool exists;\n        address nextId;                  // Id of next node (smaller ICR) in the list\n        address prevId;                  // Id of previous node (larger ICR) in the list\n    }\n\n    // Information for the list\n    struct Data {\n        address head;                        // Head of the list. Also the node in the list with the largest ICR\n        address tail;                        // Tail of the list. Also the node in the list with the smallest ICR\n        uint256 maxSize;                     // Maximum size of the list\n        uint256 size;                        // Current size of the list\n        mapping (address => Node) nodes;     // Track the corresponding ids for each node in the list\n    }\n\n    Data data;\n\n    // --- Modifiers ---\n\n    modifier onlyBorrowerOperations() {\n        require(_msgSender() == borrowerOperationsAddress, \"SortedCDPs: Caller is not the BorrowerOperations contract\");\n        _;\n    }\n\n    modifier onlyCDPManager() {\n        require(_msgSender() == CDPManagerAddress, \"SortedCDPs: Caller is not the CDPManager\");\n        _;\n    }\n\n     modifier onlyBMorCDPM() {\n        address sender = _msgSender();\n        require(sender == CDPManagerAddress || sender == borrowerOperationsAddress, \n                \"SortedCDPs: Caller is neither BM nor CDPM\");\n        _;\n    }\n\n    // --- Dependency setters --- \n\n    function setCDPManager(address _CDPManagerAddress) public onlyOwner {\n        CDPManagerAddress = _CDPManagerAddress;\n        cdpManager = ICDPManager(_CDPManagerAddress);\n        emit CDPManagerAddressChanged(_CDPManagerAddress);\n    }\n\n    function setBorrowerOperations(address _borrowerOperationsAddress) public onlyOwner {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n    }\n\n    constructor() public {\n        data.maxSize = 10000000;\n    }\n\n    /*\n     * @dev Set the maximum size of the list\n     * @param _size Maximum size\n     */\n    function setMaxSize(uint256 _size) public onlyOwner {\n        // New max size must be greater than old max size\n        require(_size > data.maxSize);\n\n        data.maxSize = _size;\n    }\n\n    /*\n     * @dev Add a node to the list\n     * @param _id Node's id\n     * @param _ICR Node's ICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n\n    function insert (address _id, uint256 _ICR, uint _price, address _prevId, address _nextId) public onlyBorrowerOperations {\n        _insert (_id, _ICR, _price, _prevId, _nextId);\n    }\n    \n    function _insert(address _id, uint256 _ICR, uint _price, address _prevId, address _nextId) internal {\n        // console.log(\"SortedCDPS.insert called\");\n        // console.log(\"00. gas left: %s\", gasleft());\n        // List must not be full\n        require(!isFull());  // 1650 gas\n        // console.log(\"01. gas left: %s\", gasleft());\n        // List must not already contain node\n        require(!contains(_id));  // 900 gas\n        // console.log(\"02. gas left: %s\", gasleft());\n        // Node id must not be null\n        require(_id != address(0));  // 26 gas\n        // console.log(\"03. gas left: %s\", gasleft());\n        // ICR must be non-zero\n        require(_ICR > 0); // 16 gas\n        // console.log(\"04. gas left: %s\", gasleft());\n\n        address prevId = _prevId; // 2 gas\n        // console.log(\"05. gas left: %s\", gasleft());\n        address nextId = _nextId; // 3 gas\n        // console.log(\"06. gas left: %s\", gasleft());\n\n        if (!validInsertPosition(_ICR, _price, prevId, nextId)) {\n            // Sender's hint was not a valid insert position\n            // Use sender's hint to find a valid insert position\n            (prevId, nextId) = findInsertPosition(_ICR, _price, prevId, nextId);  // 14500k gas with 1 traversals  \n        }\n        // console.log(\"07. gas left: %s\", gasleft());\n        \n         data.nodes[_id].exists = true;  // *** 21000 gas for false --> true\n        \n        // console.log(\"08. gas left: %s\", gasleft());\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // console.log(\"9a. gas left: %s\", gasleft());\n            // Insert as head and tail\n            data.head = _id; // 21000 gas\n            // console.log(\"9b. gas left: %s\", gasleft());\n            data.tail = _id; // 21000 gas\n            // console.log(\"9bb. gas left: %s\", gasleft());\n        } else if (prevId == address(0)) { // 117 gas\n            // console.log(\"9c. gas left: %s\", gasleft());\n            // Insert before `prevId` as the head\n            data.nodes[_id].nextId = data.head; // 2600 gas\n            // console.log(\"9d. gas left: %s\", gasleft());\n            data.nodes[data.head].prevId = _id;  // 21800 gas\n            // console.log(\"9e. gas left: %s\", gasleft());\n            data.head = _id; // 5800 gas\n            // console.log(\"9ee. gas left: %s\", gasleft());\n        } else if (nextId == address(0)) {\n            // console.log(\"9f. gas left: %s\", gasleft());\n            // Insert after `nextId` as the tail\n            data.nodes[_id].prevId = data.tail;\n            // console.log(\"9g. gas left: %s\", gasleft());\n            data.nodes[data.tail].nextId = _id;\n            // console.log(\"9h. gas left: %s\", gasleft());\n            data.tail = _id;\n            // console.log(\"9i. gas left: %s\", gasleft());\n        } else { // 127 gas\n            // console.log(\"9j. gas left: %s\", gasleft());\n            // Insert at insert position between `prevId` and `nextId`\n            data.nodes[_id].nextId = nextId; // 1800 gas\n            // console.log(\"9k. gas left: %s\", gasleft());\n            data.nodes[_id].prevId = prevId; // 21000 gas\n            // console.log(\"9l. gas left: %s\", gasleft());\n            data.nodes[prevId].nextId = _id; // 6000 gas\n            // console.log(\"9m. gas left: %s\", gasleft());\n            data.nodes[nextId].prevId = _id; // 6000 gas\n            // console.log(\"9n. gas left: %s\", gasleft());\n        }\n\n        data.size = data.size.add(1); // 5900 gas\n        // ;  \n        // console.log(\"10. gas left: %s\", gasleft());\n        // console.log(\"SortedCDPs.insert func end\");\n    }\n\n    function remove(address _id) public onlyCDPManager {\n        _remove(_id);\n    }\n\n    /*\n     * @dev Remove a node from the list\n     * @param _id Node's id\n     */\n    function _remove(address _id) internal {\n        // List must contain the node\n        // console.log(\"00. gas left: %s\", gasleft());\n        require(contains(_id)); // 940 gas\n        // console.log(\"01. gas left: %s\", gasleft());\n\n        if (data.size > 1) { // 800 gas\n            // console.log(\"02. gas left: %s\", gasleft());\n            // List contains more than a single node\n            if (_id == data.head) { // 800 gas\n                // console.log(\"03. gas left: %s\", gasleft());\n                // The removed node is the head\n                // Set head to next node\n                data.head = data.nodes[_id].nextId; // 6800 gas\n                // console.log(\"04. gas left: %s\", gasleft());\n                // Set prev pointer of new head to null\n                data.nodes[data.head].prevId = address(0); // 6700 gas\n                // console.log(\"05. gas left: %s\", gasleft());\n            } else if (_id == data.tail) {\n                // console.log(\"06. gas left: %s\", gasleft());\n                // The removed node is the tail\n                // Set tail to previous node\n                data.tail = data.nodes[_id].prevId;\n                // console.log(\"07. gas left: %s\", gasleft());\n                // Set next pointer of new tail to null\n                data.nodes[data.tail].nextId = address(0);\n                // console.log(\"08. gas left: %s\", gasleft());\n            } else {\n                // The removed node is neither the head nor the tail\n                // Set next pointer of previous node to the next node\n                // console.log(\"09. gas left: %s\", gasleft());\n                data.nodes[data.nodes[_id].prevId].nextId = data.nodes[_id].nextId; // 7600 gas\n                //  console.log(\"10. gas left: %s\", gasleft());\n                // Set prev pointer of next node to the previous node\n                data.nodes[data.nodes[_id].nextId].prevId = data.nodes[_id].prevId; // 7600 gas\n                //  console.log(\"11. gas left: %s\", gasleft());\n            }\n        } else {\n            // List contains a single node\n            // Set the head and tail to null\n            //  console.log(\"12. gas left: %s\", gasleft());\n            data.head = address(0);\n            //  console.log(\"13. gas left: %s\", gasleft());\n            data.tail = address(0);\n            //  console.log(\"14. gas left: %s\", gasleft());\n        }\n\n        delete data.nodes[_id]; // ** 11100 gas\n        // console.log(\"15. gas left: %s\", gasleft());\n        data.size = data.size.sub(1); // ** 5900 gas\n        // console.log(\"16. gas left: %s\", gasleft());\n    }\n\n    /*\n     * @dev Re-insert the node at a new position, based on its new ICR\n     * @param _id Node's id\n     * @param _newICR Node's new ICR\n     * @param _prevId Id of previous node for the new insert position\n     * @param _nextId Id of next node for the new insert position\n     */\n    function reInsert(address _id, uint256 _newICR, uint _price, address _prevId, address _nextId) public onlyBMorCDPM {\n        // List must contain the node\n        require(contains(_id));\n\n        // Remove node from the list\n        _remove(_id);\n\n        if (_newICR > 0) {\n            // Insert node if it has a non-zero ICR\n            _insert(_id, _newICR, _price, _prevId, _nextId);\n        }\n    }\n\n    /*\n     * @dev Checks if the list contains a node\n     * @param _transcoder Address of transcoder\n     */\n    function contains(address _id) public view returns (bool) {\n        return data.nodes[_id].exists;\n    }\n\n    /*\n     * @dev Checks if the list is full\n     */\n    function isFull() public view returns (bool) {\n        return data.size == data.maxSize;\n    }\n\n    /*\n     * @dev Checks if the list is empty\n     */\n    function isEmpty() public view returns (bool) {\n        return data.size == 0;\n    }\n\n    /*\n     * @dev Returns the current size of the list\n     */\n    function getSize() public view returns (uint256) {\n        return data.size;\n    }\n\n    /*\n     * @dev Returns the maximum size of the list\n     */\n    function getMaxSize() public view returns (uint256) {\n        return data.maxSize;\n    }\n\n    /*\n     * @dev Returns the first node in the list (node with the largest ICR)\n     */\n    function getFirst() public view returns (address) {\n        return data.head;\n    }\n\n    /*\n     * @dev Returns the last node in the list (node with the smallest ICR)\n     */\n    function getLast() public view returns (address) {\n        return data.tail;\n    }\n\n    /*\n     * @dev Returns the next node (with a smaller ICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getNext(address _id) public view returns (address) {\n        return data.nodes[_id].nextId;\n    }\n\n    /*\n     * @dev Returns the previous node (with a larger ICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getPrev(address _id) public view returns (address) {\n        return data.nodes[_id].prevId;\n    }\n\n    /*\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given ICR\n     * @param _ICR Node's ICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function validInsertPosition(uint256 _ICR, uint _price, address _prevId, address _nextId) public view returns (bool) {\n        if (_prevId == address(0) && _nextId == address(0)) {\n            // `(null, null)` is a valid insert position if the list is empty\n            return isEmpty();\n        } else if (_prevId == address(0)) {\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\n            return data.head == _nextId && _ICR >= cdpManager.getCurrentICR(_nextId, _price);\n        } else if (_nextId == address(0)) {\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\n            return data.tail == _prevId && _ICR <= cdpManager.getCurrentICR(_prevId, _price);\n        } else {\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_ICR` falls between the two nodes' ICRs\n            return data.nodes[_prevId].nextId == _nextId && \n                   cdpManager.getCurrentICR(_prevId, _price) >= _ICR && \n                   _ICR >= cdpManager.getCurrentICR(_nextId, _price);\n        }\n    }\n\n    /*\n     * @dev Descend the list (larger ICRs to smaller ICRs) to find a valid insert position\n     * @param _ICR Node's ICR\n     * @param _startId Id of node to start ascending the list from\n     */\n    function descendList(uint256 _ICR, uint _price, address _startId) private view returns (address, address) {\n        // If `_startId` is the head, check if the insert position is before the head\n        if (data.head == _startId && _ICR >= cdpManager.getCurrentICR(_startId, _price)) {\n            return (address(0), _startId);\n        }\n\n        address prevId = _startId;\n        address nextId = data.nodes[prevId].nextId;\n\n        // Descend the list until we reach the end or until we find a valid insert position\n        while (prevId != address(0) && !validInsertPosition(_ICR, _price, prevId, nextId)) {\n            prevId = data.nodes[prevId].nextId;\n            nextId = data.nodes[prevId].nextId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Ascend the list (smaller ICRs to larger ICRs) to find a valid insert position\n     * @param _ICR Node's ICR\n     * @param _startId Id of node to start descending the list from\n     */\n    function ascendList(uint256 _ICR, uint _price, address _startId) private view returns (address, address) {\n        // If `_startId` is the tail, check if the insert position is after the tail\n        if (data.tail == _startId && _ICR <= cdpManager.getCurrentICR(_startId, _price)) {\n            return (_startId, address(0));\n        }\n\n        address nextId = _startId;\n        address prevId = data.nodes[nextId].prevId;\n\n        // Ascend the list until we reach the end or until we find a valid insertion point\n        while (nextId != address(0) && !validInsertPosition(_ICR, _price, prevId, nextId)) {\n            nextId = data.nodes[nextId].prevId;\n            prevId = data.nodes[nextId].prevId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Find the insert position for a new node with the given ICR\n     * @param _ICR Node's ICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function findInsertPosition(uint256 _ICR, uint _price, address _prevId, address _nextId) public view returns (address, address) {\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (prevId != address(0)) {\n            if (!contains(prevId) || _ICR > cdpManager.getCurrentICR(prevId, _price)) {\n                // `prevId` does not exist anymore or now has a smaller ICR than the given ICR\n                prevId = address(0);\n            }\n        }\n\n        if (nextId != address(0)) {\n            if (!contains(nextId) || _ICR < cdpManager.getCurrentICR(nextId, _price)) {\n                // `nextId` does not exist anymore or now has a larger ICR than the given ICR\n                nextId = address(0);\n            }\n        }\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // No hint - descend list starting from head\n            return descendList(_ICR, _price, data.head);\n        } else if (prevId == address(0)) {\n            // No `prevId` for hint - ascend list starting from `nextId`\n            return ascendList(_ICR, _price, nextId);\n        } else if (nextId == address(0)) {\n            // No `nextId` for hint - descend list starting from `prevId`\n            return descendList(_ICR, _price, prevId);\n        } else {\n            // Descend list starting from `prevId`\n            return descendList(_ICR, _price, prevId);\n        }\n    }\n}"
    },
    "contracts/PoolManager.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport './Interfaces/IPool.sol';\nimport './Interfaces/IPoolManager.sol';\nimport './Interfaces/ICDPManager.sol';\nimport './Interfaces/IStabilityPool.sol';\nimport './Interfaces/IPriceFeed.sol';\nimport './Interfaces/ICLVToken.sol';\nimport './DeciMath.sol';\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\n// PoolManager maintains all pools \ncontract PoolManager is Ownable, IPoolManager {\n    using SafeMath for uint;\n\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event CDPManagerAddressChanged(address _newCDPManagerAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event CLVTokenAddressChanged(address _newCLVTokenAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    \n    event UserSnapshotUpdated(uint _P, uint _S);\n    event P_Updated(uint _P);\n    event S_Updated(uint _S);\n    event UserDepositChanged(address indexed _user, uint _amount);\n    event ETHGainWithdrawn(address indexed _user, uint _ETH);\n    event ETHGainWithdrawnToCDP(address indexed _CDPOwner, uint _ETH);\n\n    // --- Connected contract declarations ---\n\n    IBorrowerOperations borrowerOperations;\n    address public borrowerOperationsAddress;\n\n    address public cdpManagerAddress;\n    ICDPManager cdpManager = ICDPManager(cdpManagerAddress);\n\n    IPriceFeed priceFeed;\n    address public priceFeedAddress;\n\n    ICLVToken CLV;\n    address public clvAddress;\n\n    IStabilityPool public stabilityPool;\n    address public stabilityPoolAddress;\n\n    IPool public activePool;\n    address public activePoolAddress;\n\n    IPool public defaultPool;\n    address public defaultPoolAddress;\n   \n   // --- Data structures ---\n   \n    mapping (address => uint) public initialDeposits;\n\n    struct Snapshot {\n        uint S;\n        uint P;\n        uint scale;\n        uint epoch;\n    }\n\n    /* P: Running product by which to multiply an initial deposit, in order to find the current compounded deposit, \n    given a series of liquidations, each of which cancel some CLV debt with the deposit. \n\n    During its lifetime, a deposit's value evolves from d0 to (d0 * P / P(0) ), where P(0) \n    is the snapshot of P taken at the instant the deposit was made. 18 DP decimal.  */\n    uint public P = 1e18;\n\n    uint public currentScale;  // Each time the scale of P shifts by 1e18, the scale is incremented by 1\n\n    uint public currentEpoch;  // With each offset that fully empties the Pool, the epoch is incremented by 1\n\n    /* S: During it's lifetime, each deposit d0 earns an ETH gain of ( d0 * [S - S(0)] )/P(0), where S(0) \n    is the snapshot of S taken at the instant the deposit was made.\n   \n    The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n\n    - The inner mapping records the sum S at different scales\n    - The outer mapping records the (scale => sum) mappings, for different epochs. */\n    mapping (uint => mapping(uint => uint)) public epochToScaleToSum;\n\n    // Map users to their individual snapshot structs\n    mapping (address => Snapshot) public snapshot;\n\n    // Error trackers for the error correction in the offset calculation\n    uint lastETHError_Offset;\n    uint lastCLVLossError_Offset;\n\n    // --- Modifiers ---\n\n    modifier onlyCDPManager() {\n        require(_msgSender() == cdpManagerAddress, \"PoolManager: Caller is not the CDPManager\");\n        _;\n    }\n\n     modifier onlyBorrowerOperations() {\n        require(_msgSender() == borrowerOperationsAddress, \"PoolManager: Caller is not the BorrowerOperations contract\");\n        _;\n    }\n\n    modifier onlyStabilityPoolorActivePool {\n        require(\n            _msgSender() == stabilityPoolAddress ||  _msgSender() ==  activePoolAddress, \n            \"PoolManager: Caller is neither StabilityPool nor ActivePool\");\n        _;\n    }\n\n    constructor() public {}\n\n    // --- Dependency setters ---\n\n    function setBorrowerOperations(address _borrowerOperationsAddress) public onlyOwner {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n    }\n\n    function setCDPManagerAddress(address _cdpManagerAddress) public onlyOwner {\n        cdpManagerAddress = _cdpManagerAddress;\n        cdpManager = ICDPManager(_cdpManagerAddress);\n        emit CDPManagerAddressChanged(_cdpManagerAddress);\n    }\n\n     function setPriceFeed(address _priceFeedAddress) public onlyOwner {\n        priceFeedAddress = _priceFeedAddress;\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n    }\n\n    function setCLVToken(address _CLVAddress) public onlyOwner {\n        clvAddress = _CLVAddress;\n        CLV = ICLVToken(_CLVAddress);\n        emit CLVTokenAddressChanged(_CLVAddress);\n    }\n\n    function setStabilityPool(address _stabilityPoolAddress) public onlyOwner {\n        stabilityPoolAddress = _stabilityPoolAddress;\n        stabilityPool = IStabilityPool(stabilityPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n    }\n\n    function setActivePool(address _activePoolAddress) public onlyOwner {\n        activePoolAddress = _activePoolAddress;\n        activePool = IPool(activePoolAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n    }\n\n    function setDefaultPool(address _defaultPoolAddress) public onlyOwner {\n        defaultPoolAddress = _defaultPoolAddress;\n        defaultPool = IPool(defaultPoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n    }\n\n    // --- Getters ---\n\n    // Return the current ETH balance of the PoolManager contract\n    function getBalance() public view returns(uint) {\n        return address(this).balance;\n    } \n    \n    // Return the total collateral ratio (TCR) of the system, based on the most recent ETH:USD price\n    function getTCR() public view returns (uint) {\n        uint price = priceFeed.getPrice();\n\n        uint activeColl = activePool.getETH();\n        uint activeDebt = activePool.getCLV();\n        uint liquidatedColl = defaultPool.getETH();\n        uint closedDebt = defaultPool.getCLV();\n\n        uint totalCollateral = activeColl.add(liquidatedColl);\n        uint totalDebt = activeDebt.add(closedDebt); \n\n        // Handle edge cases of div-by-0\n        if(totalCollateral == 0 && totalDebt == 0 ) {\n            return 1;\n        }  else if (totalCollateral != 0 && totalDebt == 0 ) {\n            return 2**256 - 1; // TCR is technically infinite\n        }\n\n        // Calculate TCR\n        uint TCR = totalCollateral.mul(price).div(totalDebt);\n        return TCR;\n    }\n\n    // Return the total active debt (in CLV) in the system\n    function getActiveDebt() public view returns (uint) {\n        return activePool.getCLV();\n    }    \n    \n    // Return the total active collateral (in ETH) in the system\n    function getActiveColl() public view returns (uint) {\n        return activePool.getETH();\n    } \n    \n    // Return the amount of closed debt (in CLV)\n    function getClosedDebt() public view returns (uint) {\n        return defaultPool.getCLV();\n    }    \n    \n    // Return the amount of closed collateral (in ETH)\n    function getLiquidatedColl() public view returns (uint) {\n        return defaultPool.getETH();\n    }\n    \n    // Return the total CLV in the Stability Pool\n    function getStabilityPoolCLV() public view returns (uint) {\n        return stabilityPool.getCLV();\n    }\n    \n    // Add the received ETH to the total active collateral\n    function addColl() public payable onlyBorrowerOperations returns (bool) {\n        // Send ETH to Active Pool and increase its recorded ETH balance\n       (bool success, ) = activePoolAddress.call.value(msg.value)(\"\");\n       assert(success == true);\n       return success;\n    }\n    \n    // Transfer the specified amount of ETH to _account and updates the total active collateral\n    function withdrawColl(address _account, uint _ETH) public onlyBorrowerOperations returns (bool) {\n        activePool.sendETH(_account, _ETH);\n        return true;\n    }\n    \n    // Issue the specified amount of CLV to _account and increases the total active debt\n    function withdrawCLV(address _account, uint _CLV) public onlyBorrowerOperations returns (bool) {\n        activePool.increaseCLV(_CLV);  // 9500\n        CLV.mint(_account, _CLV);  // 37500\n         \n        return true;\n    }\n    \n    // Burn the specified amount of CLV from _account and decreases the total active debt\n    function repayCLV(address _account, uint _CLV) public onlyBorrowerOperations returns (bool) {\n        activePool.decreaseCLV(_CLV);\n        CLV.burn(_account, _CLV);\n        return true;\n    }           \n    \n    // Update the Active Pool and the Default Pool when a CDP gets closed\n    function liquidate(uint _CLV, uint _ETH) public onlyCDPManager returns (bool) {\n        // Transfer the debt & coll from the Active Pool to the Default Pool\n        defaultPool.increaseCLV(_CLV);\n        activePool.decreaseCLV(_CLV);\n        activePool.sendETH(defaultPoolAddress, _ETH);\n\n        return true;\n    }\n\n    // Move a CDP's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function moveDistributionRewardsToActivePool(uint _CLV, uint _ETH) public onlyCDPManager returns (bool) {\n        // Transfer the debt & coll from the Default Pool to the Active Pool\n        defaultPool.decreaseCLV(_CLV);  \n        activePool.increaseCLV(_CLV); \n        defaultPool.sendETH(activePoolAddress, _ETH); \n \n        return true;\n    }\n\n    // Burn the received CLV, transfers the redeemed ETH to _account and updates the Active Pool\n    function redeemCollateral(address _account, uint _CLV, uint _ETH) public onlyCDPManager returns (bool) {\n        // Update Active Pool CLV, and send ETH to account\n        activePool.decreaseCLV(_CLV);  \n        activePool.sendETH(_account, _ETH); \n\n        CLV.burn(_account, _CLV); \n        return true;\n    }\n\n    /* Return the ETH gain earned by the deposit. Given by the formula:  E = d0 * (S - S(0))/P(0)\n    where S(0), P(0) are the depositor's snapshots of the sum S and product P, respectively. */\n    function getCurrentETHGain(address _user) public view returns(uint) {\n        uint initialDeposit = initialDeposits[_user];\n\n        if (initialDeposit == 0) { return 0; }\n\n        uint snapshot_S = snapshot[_user].S;  \n        uint snapshot_P = snapshot[_user].P;\n        uint scaleSnapshot = snapshot[_user].scale;\n        uint epochSnapshot = snapshot[_user].epoch;\n\n        uint ETHGain;\n\n        /* Grab the reward sum from the epoch at which the deposit was made. The reward may span up to \n        one scale change.  \n        If it does, the second portion of the reward is scaled by 1e18. \n        If the reward spans no scale change, the second portion will be 0. */\n        uint firstPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot].sub(snapshot_S);\n        uint secondPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot.add(1)].div(1e18);\n\n        ETHGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(snapshot_P).div(1e18);\n        \n        return ETHGain;\n    }\n\n    /* Return the user's compounded deposit.  Given by the formula:  d = d0 * P/P(0)\n    where P_(0) is the depositor's snapshot of the product P. */\n    function getCompoundedCLVDeposit(address _user) public view returns(uint) {\n        uint userDeposit = initialDeposits[_user];\n\n        if (userDeposit == 0) { return 0; }\n\n        uint snapshot_P = snapshot[_user].P; \n        uint scaleSnapshot = snapshot[_user].scale;\n        uint epochSnapshot = snapshot[_user].epoch;\n        \n        // If deposit was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot < currentEpoch) { return 0; }\n\n        uint compoundedDeposit;\n        uint scaleDiff = currentScale.sub(scaleSnapshot);\n    \n        /* Compute the compounded deposit. If a scale change in P was made during the deposit's lifetime, \n        account for it.  If more than one scale change was made, then the deposit has decreased by a factor of \n        at least 1e-18 -- so return 0.*/\n        if (scaleDiff == 0) { \n            compoundedDeposit = userDeposit.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedDeposit = userDeposit.mul(P).div(snapshot_P).div(1e18);\n        } else {\n            compoundedDeposit = 0;\n        }\n\n        // If compounded deposit is less than a billionth of the initial deposit, return 0\n        if (compoundedDeposit < userDeposit.div(1e9)) { return 0; }\n\n        return compoundedDeposit;\n    }\n\n    // --- Internal Stability Pool functions --- \n\n    // Deposit _amount CLV from _address, to the Stability Pool.\n    function depositCLV(address _address, uint _amount) internal returns(bool) {\n        require(initialDeposits[_address] == 0, \"PoolManager: user already has a StabilityPool deposit\");\n    \n        // Transfer the CLV tokens from the user to the Stability Pool's address, and update its recorded CLV\n        CLV.sendToPool(_address, stabilityPoolAddress, _amount);\n        stabilityPool.increaseCLV(_amount);\n       \n        // Record the deposit made by user\n        initialDeposits[_address] = _amount;\n    \n        // Record new individual snapshots of the running product P and sum S for the user\n        snapshot[_address].P = P;\n        snapshot[_address].S = epochToScaleToSum[currentEpoch][currentScale];\n        snapshot[_address].scale = currentScale;\n        snapshot[_address].epoch = currentEpoch;\n\n        emit UserSnapshotUpdated(snapshot[_address].P, snapshot[_address].S);\n        emit UserDepositChanged(_address, _amount);\n        return true;\n    }\n\n   // Transfers _address's compounded deposit and ETH gain, to _address.\n    function retrieveToUser(address _address) internal returns(uint compoundedCLVDeposit, uint ETHGain) {\n        uint userDeposit = initialDeposits[_address];\n\n        ETHGain = getCurrentETHGain(_address);\n        compoundedCLVDeposit = getCompoundedCLVDeposit(_address);\n        initialDeposits[_address] = 0;\n\n        emit UserDepositChanged(_address, 0);\n\n        // Send CLV to user and decrease CLV in Pool\n        CLV.returnFromPool(stabilityPoolAddress, _address, DeciMath.getMin(compoundedCLVDeposit, stabilityPool.getCLV()));\n    \n        stabilityPool.decreaseCLV(compoundedCLVDeposit);\n    \n        // Send ETH to user\n        stabilityPool.sendETH(_address, ETHGain);\n        emit ETHGainWithdrawn(_address, ETHGain);\n\n        return (compoundedCLVDeposit, ETHGain);\n    }\n\n    // Transfer _address's compounded deposit to _address, and their ETH gain to their CDP.\n    function retrieveToCDP(address _address, address _hint) internal returns(uint compoundedCLVDeposit, uint ETHGain) {\n        uint userDeposit = initialDeposits[_address];  \n        require(userDeposit > 0, 'PoolManager: User must have a non-zero deposit');  \n        \n        ETHGain = getCurrentETHGain(_address);\n        compoundedCLVDeposit = getCompoundedCLVDeposit(_address);\n      \n        initialDeposits[_address] = 0; \n       \n        emit UserDepositChanged(_address, 0); \n      \n        // Send CLV to user and decrease CLV in StabilityPool\n        CLV.returnFromPool(stabilityPoolAddress, _address, DeciMath.getMin(compoundedCLVDeposit, stabilityPool.getCLV()));\n        \n        stabilityPool.decreaseCLV(compoundedCLVDeposit);\n       \n        // Pull ETHShare from StabilityPool, and send to CDP\n        stabilityPool.sendETH(address(this), ETHGain); \n        borrowerOperations.addColl.value(ETHGain)(_address, _hint); \n        emit ETHGainWithdrawnToCDP(_address, ETHGain);\n   \n        return (compoundedCLVDeposit, ETHGain);\n    }\n\n    // --- External StabilityPool Functions ---\n\n    /* Send ETHGain to user's address, and updates their deposit, \n    setting newDeposit = compounded deposit + amount. */\n    function provideToSP(uint _amount) external returns(bool) {\n        address user = _msgSender();\n\n        // If user has no deposit, make one with _amount\n        if (initialDeposits[user] == 0) {\n            depositCLV(user, _amount);\n            return true;\n        }\n\n        /* If user already has a deposit, retrieve their ETH gain and current deposit,\n         then make a new composite deposit */\n        (uint returnedCLV, ) = retrieveToUser(user);\n\n        uint newDeposit = returnedCLV + _amount;\n        depositCLV(user, newDeposit);\n\n        return true;\n    }\n\n    /* Withdraw _amount of CLV and the caller’s entire ETH gain from the \n    Stability Pool, and updates the caller’s reduced deposit. \n\n    If  _amount is 0, the user only withdraws their ETH gain, no CLV.\n    If _amount > userDeposit, the user withdraws all their ETH gain, and all of their compounded deposit.\n\n    In all cases, the entire ETH gain is sent to user. */\n    function withdrawFromSP(uint _amount) external returns(bool) {\n        address user = _msgSender();\n       \n        // Retrieve CLV and ETH for the user\n        (uint returnedCLV, ) = retrieveToUser(user);\n\n        // If requested withdrawal amount is less than available CLV, re-deposit the difference.\n        if (_amount < returnedCLV) {\n            depositCLV(user, returnedCLV.sub(_amount));\n        }\n\n        return true;\n    }\n\n    /* Transfer the caller’s entire ETH gain from the Stability Pool to the caller’s CDP, and leaves\n    their compounded deposit in the Stability Pool. */\n    function withdrawFromSPtoCDP(address _user, address _hint) external returns(bool) {\n        uint userDeposit = initialDeposits[_user]; \n       \n        if (userDeposit == 0) { return false; } \n        \n        // Retrieve all CLV to user's CLV balance, and ETH to their CDP\n        (uint returnedCLV, ) = retrieveToCDP(_user, _hint); \n        \n        depositCLV(_user, returnedCLV); \n        return true;\n    }\n\n     /* Cancel out the specified _debt against the CLV contained in the Stability Pool (as far as possible)  \n    and transfers the CDP's ETH collateral from ActivePool to StabilityPool. \n    Returns the amount of debt that could not be cancelled, and the corresponding ether.\n    Only callable from close() and closeCDPs() functions in CDPManager */\n  function offset(uint _debt, uint _coll,  uint CLVInPool) \n    external \n    payable \n    onlyCDPManager \n    returns (uint debtRemainder, uint collRemainder)  {    \n        uint totalCLVDeposits = stabilityPool.getCLV(); \n        \n        // If the debt is larger than the deposited CLV, offset an amount of debt corresponding to the latter\n        uint debtToOffset = DeciMath.getMin(_debt, CLVInPool);  \n  \n        // Collateral to be added in proportion to the debt that is cancelled \n        uint collToAdd = _coll.mul(debtToOffset).div(_debt);\n        \n        (uint ETHGainPerUnitStaked,\n         uint CLVLossPerUnitStaked) = computeRewardsPerUnitStaked(collToAdd, debtToOffset, totalCLVDeposits);\n\n        updateRewardSumAndProduct(ETHGainPerUnitStaked, CLVLossPerUnitStaked);\n\n        moveOffsetCollAndDebt(collToAdd, debtToOffset);\n\n        // Return the amount of debt & coll that could not be offset against the Stability Pool due to insufficiency\n        debtRemainder = _debt.sub(debtToOffset);\n        collRemainder = _coll.sub(collToAdd);\n\n        return (debtRemainder, collRemainder);\n    }\n\n    // --- Offset helper functions ---\n\n    function computeRewardsPerUnitStaked(uint collToAdd, uint debtToOffset, uint totalCLVDeposits) \n    internal \n    returns(uint ETHGainPerUnitStaked, uint CLVLossPerUnitStaked) \n    {\n        uint CLVLossNumerator = debtToOffset.mul(1e18).sub(lastCLVLossError_Offset);\n        uint ETHNumerator = collToAdd.mul(1e18).add(lastETHError_Offset);\n\n        // Compute the CLV and ETH rewards, and error corrections\n        uint CLVLossPerUnitStaked;\n\n        if (debtToOffset >= totalCLVDeposits) {\n            CLVLossPerUnitStaked = 1e18;\n            lastCLVLossError_Offset = 0;\n        } else {\n            CLVLossPerUnitStaked = (CLVLossNumerator.div(totalCLVDeposits)).add(1); // add 1 to make error in quotient positive\n             lastCLVLossError_Offset = (CLVLossPerUnitStaked.mul(totalCLVDeposits)).sub(CLVLossNumerator);\n        } \n\n        uint ETHGainPerUnitStaked = ETHNumerator.div(totalCLVDeposits); \n        lastETHError_Offset = ETHNumerator.sub(ETHGainPerUnitStaked.mul(totalCLVDeposits)); \n\n        return (ETHGainPerUnitStaked, CLVLossPerUnitStaked);\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function updateRewardSumAndProduct(uint ETHGainPerUnitStaked, uint CLVLossPerUnitStaked) internal {\n         // Make product factor 0 if there was a pool-emptying. Otherwise, it is (1 - CLVLossPerUnitStaked)\n        uint newProductFactor = CLVLossPerUnitStaked >= 1e18 ? 0 : uint(1e18).sub(CLVLossPerUnitStaked);\n     \n        // Update the ETH reward sum at the current scale\n        uint marginalETHGain = ETHGainPerUnitStaked.mul(P);\n        epochToScaleToSum[currentEpoch][currentScale] = epochToScaleToSum[currentEpoch][currentScale].add(marginalETHGain);\n        emit S_Updated(epochToScaleToSum[currentEpoch][currentScale]); \n\n       // If the pool was emptied, increment the epoch and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpoch.add(1);\n            currentScale = 0;\n            P = 1e18;\n    \n        // If multiplying P by a non-zero product factor would round P to zero, increment the scale \n        } else if (P.mul(newProductFactor) < 1e18) {\n            P = P.mul(newProductFactor);\n            currentScale = currentScale.add(1);\n         } else {\n            P = P.mul(newProductFactor).div(1e18); \n        }\n\n        emit P_Updated(P); \n    }\n\n    function moveOffsetCollAndDebt(uint collToAdd, uint debtToOffset) internal {\n        // Cancel the liquidated CLV debt with the CLV in the stability pool\n        activePool.decreaseCLV(debtToOffset);  \n        stabilityPool.decreaseCLV(debtToOffset); \n       \n        // Send ETH from Active Pool to Stability Pool\n        activePool.sendETH(stabilityPoolAddress, collToAdd);  \n\n        // Burn the debt that was successfully offset\n        CLV.burn(stabilityPoolAddress, debtToOffset); \n    }\n\n    function () external payable onlyStabilityPoolorActivePool {}\n}    "
    },
    "contracts/PriceFeed.sol": {
      "content": "pragma solidity ^0.5.16;\n\n\nimport \"./Interfaces/ICDPManager.sol\";\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Interfaces/IDeployedAggregator.sol\";\nimport \"./Interfaces/AggregatorInterface.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract PriceFeed is Ownable, IPriceFeed {\n    using SafeMath for uint256;\n\n    uint256 constant DIGITS = 1e18;\n    uint256 public price = 200 * DIGITS;\n\n    address public cdpManagerAddress;\n    address public poolManagerAddress;\n    \n    ICDPManager cdpManager;\n\n    // Mainnet Chainlink aggregator\n    address public priceAggregatorAddress;\n    IDeployedAggregator priceAggregator;\n\n    // Testnet Chainlink aggregator\n    address public priceAggregatorAddress_Testnet;\n    AggregatorInterface priceAggregator_Testnet;\n\n    event PriceUpdated(uint256 _newPrice);\n    event CDPManagerAddressChanged(address _cdpManagerAddress);\n    event PoolManagerAddressChanged(address _poolManagerAddress);\n\n    // --- Dependency setters ---\n\n    function setCDPManagerAddress(address _cdpManagerAddress) public onlyOwner {\n        cdpManagerAddress = _cdpManagerAddress;\n        cdpManager = ICDPManager(_cdpManagerAddress);\n        emit CDPManagerAddressChanged(_cdpManagerAddress);\n    }\n\n    function setPoolManagerAddress(address _poolManagerAddress) public onlyOwner {\n        poolManagerAddress = _poolManagerAddress;\n        emit PoolManagerAddressChanged(_poolManagerAddress);\n    }\n\n    // Mainnet Chainlink address setter\n    function setAggregator(address _priceAggregatorAddress) public onlyOwner {\n        priceAggregatorAddress = _priceAggregatorAddress;\n        priceAggregator = IDeployedAggregator(_priceAggregatorAddress);\n    }\n\n    // Testnet Chainlink address setter\n    function setAggregator_Testnet(address _priceAggregatorAddress) public onlyOwner {\n        priceAggregator_Testnet = AggregatorInterface(_priceAggregatorAddress);\n    }\n\n    // --- Modifiers ---\n\n    modifier onlyCDPManagerOrPoolManager {\n        require(_msgSender() == cdpManagerAddress ||_msgSender() == poolManagerAddress,\n            \"PriceFeed: Caller is neither CDPManager nor PoolManager\"\n        );\n        _;\n    }\n\n    // --- Functions ---\n\n    function getPrice() public view returns (uint256) {\n        return price;\n    }\n\n    // --- DEVELOPMENT FUNCTIONALITY  ---\n\n    /* Manual public price setter. \n    TODO: remove before mainnet deployment. */\n    function setPrice(uint256 _price) public returns (bool) {\n        price = _price;\n        emit PriceUpdated(price);\n        return true;\n    }\n\n    // --- MAINNET FUNCTIONALITY ---\n\n    // TODO: convert received Chainlink price to precision-18 before setting state variable\n    function updatePrice() public onlyCDPManagerOrPoolManager returns (uint256) {\n        price = getLatestPrice();\n        emit PriceUpdated(price);\n        return price;\n    }\n\n    function getLatestPrice() public view returns (uint256) {\n        int256 intPrice = priceAggregator.currentAnswer();\n        require(intPrice >= 0, \"Price response from aggregator is negative int\");\n\n        return uint256(intPrice);\n    }\n\n    function getLatestAnswerID() public view returns (uint256) {\n        return priceAggregator.latestCompletedAnswer();\n    }\n\n    // Get the block timestamp at which the reference price was last updated\n    function getLatestTimestamp() public view returns (uint256) {\n        return priceAggregator.updatedHeight();\n    }\n\n    // ---- ROPSTEN FUNCTIONALITY - TODO: Remove before Mainnet deployment ----\n\n    function updatePrice_Testnet() public returns (uint256) {\n        price = getLatestPrice_Testnet();\n        emit PriceUpdated(price);\n        return price;\n    }\n\n    function getLatestPrice_Testnet() public view returns (uint256) {\n        int256 intPrice = priceAggregator_Testnet.latestAnswer();\n        require( intPrice >= 0, \"Price response from aggregator is negative int\");\n\n        return uint256(intPrice).mul(10000000000);\n    }\n\n    // Get the block timestamp at which the reference data was last updated\n    function getLatestTimestamp_Testnet() public view returns (uint256) {\n        uint256 latestTimestamp = priceAggregator_Testnet.latestTimestamp();\n\n        return latestTimestamp;\n    }\n\n    // Get the past price from 'n' rounds ago\n    function getPreviousPrice_Testnet(uint256 _n) public view returns (uint256) {\n        uint256 latestAnswerID = priceAggregator_Testnet.latestRound();\n        require(_n <= latestAnswerID, \"Not enough history\");\n\n        int256 prevPrice = priceAggregator_Testnet.getAnswer(latestAnswerID - _n);\n        require(prevPrice >= 0, \"Price response from aggregator is negative int\");\n\n        return uint256(prevPrice).mul(10000000000);\n    }\n\n    // Get the block timestamp from the round that occurred 'n' rounds ago\n    function getPreviousTimestamp_Testnet(uint256 _n) public view returns (uint256) {\n        uint256 latestAnswerID = priceAggregator_Testnet.latestRound();\n        require(_n <= latestAnswerID, \"Not enough history\");\n\n        return priceAggregator_Testnet.getTimestamp(latestAnswerID - _n);\n    }\n}\n\n"
    },
    "contracts/StabilityPool.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport './Interfaces/IStabilityPool.sol';\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract StabilityPool is Ownable, IStabilityPool {\n    using SafeMath for uint256;\n\n    address public poolManagerAddress;\n    address public defaultPoolAddress;\n    address public activePoolAddress;\n    uint256 public ETH;  // deposited ether tracker\n    \n    // Total CLV held in the pool. Changes when users deposit/withdraw, and when CDP debt is offset.\n    uint256 public totalCLVDeposits; \n\n    constructor() public {}\n\n    // --- Contract setters ---\n\n    function setPoolManagerAddress(address _poolManagerAddress) public onlyOwner {\n        poolManagerAddress = _poolManagerAddress;\n        emit PoolManagerAddressChanged(poolManagerAddress);\n    }\n\n    function setActivePoolAddress(address _activePoolAddress) public onlyOwner {\n        activePoolAddress = _activePoolAddress;\n        emit ActivePoolAddressChanged(activePoolAddress);\n    }\n    \n    function setDefaultPoolAddress(address _defaultPoolAddress) public onlyOwner {\n        defaultPoolAddress = _defaultPoolAddress; \n        emit DefaultPoolAddressChanged(defaultPoolAddress);\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getETH() public view returns(uint) {\n        return ETH;\n    }\n\n    function getCLV() public view returns(uint) {\n        return totalCLVDeposits;\n    }\n\n    // --- Pool functionality ---\n\n    function sendETH(address _account, uint _amount) public onlyPoolManager returns(bool){\n        ETH = ETH.sub(_amount);\n        (bool success, ) = _account.call.value(_amount)(\"\");  // use call.value()('') as per Consensys latest advice \n        assert(success == true);\n    \n        emit ETHBalanceUpdated(ETH);\n        emit EtherSent(_account, _amount);\n        return success;\n    }\n\n    function increaseCLV(uint _amount) public onlyPoolManager () {\n        totalCLVDeposits  = totalCLVDeposits.add(_amount);\n        emit CLVBalanceUpdated(totalCLVDeposits);\n    }\n\n    function decreaseCLV(uint _amount) public onlyPoolManager () {\n        totalCLVDeposits = totalCLVDeposits.sub(_amount);\n        emit CLVBalanceUpdated(totalCLVDeposits);\n    }\n\n    /* Returns the raw ether balance at StabilityPool address.  \n    Not necessarily equal to the ETH state variable - ether can be forcibly sent to contracts. */\n    function getRawETHBalance() public view returns(uint) {\n        return address(this).balance;\n    }\n\n    modifier onlyPoolManager {\n        require(_msgSender() == poolManagerAddress, \"StabilityPool:  Caller is not the PoolManager\");\n        _;\n    }\n\n    modifier onlyPoolManagerOrPool {\n        require(\n            _msgSender() == poolManagerAddress || \n            _msgSender() == activePoolAddress || \n            _msgSender() == defaultPoolAddress, \n            \"StabilityPool: Caller is neither the PoolManager nor a Pool\");\n        _;\n    }\n\n    function () external payable onlyPoolManagerOrPool {\n        ETH = ETH.add(msg.value);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}