{
  "language": "Solidity",
  "sources": {
    "contracts/ActivePool.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\nimport './Interfaces/IPool.sol';\r\nimport '@openzeppelin/contracts/ownership/Ownable.sol';\r\nimport '@openzeppelin/contracts/math/SafeMath.sol';\r\nimport \"@nomiclabs/buidler/console.sol\";\r\n\r\ncontract ActivePool is Ownable, IPool {\r\n    using SafeMath for uint256;\r\n\r\n    address public poolManagerAddress;\r\n    address public stabilityPoolAddress;\r\n    address public defaultPoolAddress;\r\n    uint256 public ETH;  // deposited ether tracker\r\n    uint256 public CLV;  // total outstanding CDP debt\r\n\r\n    constructor() public {}\r\n\r\n    // --- Contract setters ---\r\n\r\n    function setPoolManagerAddress(address _poolManagerAddress) public onlyOwner {\r\n        poolManagerAddress = _poolManagerAddress;\r\n        emit PoolManagerAddressChanged(_poolManagerAddress);\r\n    }\r\n\r\n    function setDefaultPoolAddress(address _defaultPoolAddress) public onlyOwner {\r\n        defaultPoolAddress = _defaultPoolAddress; \r\n        emit DefaultPoolAddressChanged(defaultPoolAddress);\r\n    }\r\n\r\n    function setStabilityPoolAddress(address _stabilityPoolAddress) public onlyOwner {\r\n        stabilityPoolAddress = _stabilityPoolAddress;\r\n        emit StabilityPoolAddressChanged(stabilityPoolAddress);\r\n    }\r\n\r\n    // --- Getters for public variables. Required by IPool interface ---\r\n\r\n    function getETH() public view returns(uint) {\r\n        return ETH;\r\n    }\r\n\r\n    function getCLV() public view returns(uint) {\r\n        return CLV;\r\n    }\r\n\r\n    // --- Pool functionality ---\r\n\r\n    function sendETH(address _account, uint _amount) public onlyPoolManager returns(bool) {\r\n        ETH = ETH.sub(_amount);\r\n        (bool success, ) = _account.call.value(_amount)(\"\");  // use call.value()('') as per Consensys latest advice \r\n        require (success == true, 'ActivePool: transaction reverted');\r\n        emit ETHBalanceUpdated(ETH);\r\n        emit EtherSent(_account, _amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseCLV(uint _amount) public onlyPoolManager () {\r\n        CLV  = CLV.add(_amount);\r\n        emit CLVBalanceUpdated(CLV);\r\n    }\r\n\r\n    function decreaseCLV(uint _amount) public onlyPoolManager () {\r\n        CLV = CLV.sub(_amount);\r\n        emit CLVBalanceUpdated(CLV);\r\n    }\r\n\r\n    /* Returns the raw ether balance at ActivePool address.  \r\n    Not necessarily equal to the ETH state variable - ether can be forcibly sent to contracts. */\r\n    function getRawETHBalance() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // --- Modifiers ---\r\n    modifier onlyPoolManager {\r\n        require(_msgSender() == poolManagerAddress, \"ActivePool: Only the poolManager is authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPoolManagerOrPool {\r\n        require(\r\n            _msgSender() == poolManagerAddress || \r\n            _msgSender() == stabilityPoolAddress || \r\n            _msgSender() == defaultPoolAddress, \r\n            \"ActivePool: only receive ETH from Pool or PoolManager\");\r\n        _;\r\n    }\r\n\r\n    function () external payable onlyPoolManagerOrPool {\r\n        ETH = ETH.add(msg.value);\r\n    }\r\n}\r\n"
    },
    "contracts/Interfaces/IPool.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\n// Common interface for the Pools.\r\ninterface IPool {\r\n    // --- Events ---\r\n    event ETHBalanceUpdated(uint _newBalance);\r\n\r\n    event CLVBalanceUpdated(uint _newBalance);\r\n\r\n    event PoolManagerAddressChanged(address _newAddress);\r\n\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n\r\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\r\n\r\n    event EtherSent(address _to, uint _amount);\r\n\r\n    // --- Functions ---\r\n    function getETH() external view returns(uint);\r\n    \r\n    function getCLV() external view returns(uint);\r\n    \r\n    function sendETH(address _account, uint _amount) external returns(bool);\r\n\r\n    function increaseCLV(uint _amount) external;\r\n\r\n    function decreaseCLV(uint _amount) external;\r\n\r\n    function getRawETHBalance() external view returns(uint);\r\n}"
    },
    "@openzeppelin/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@nomiclabs/buidler/console.sol": {
      "content": "pragma solidity >= 0.5.0 <0.7.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction log() internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log()\"));\n\t\tignored;\n\t}\tfunction logInt(int p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(int)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logByte(byte p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(byte)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n}\n"
    },
    "contracts/CDPManager.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\nimport \"./Interfaces/ICDPManager.sol\";\r\nimport \"./Interfaces/ICLVToken.sol\";\r\nimport \"./Interfaces/IPriceFeed.sol\";\r\nimport \"./Interfaces/ISortedCDPs.sol\";\r\nimport \"./Interfaces/IPoolManager.sol\";\r\nimport \"./DeciMath.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\r\nimport \"@nomiclabs/buidler/console.sol\";\r\n\r\ncontract CDPManager is Ownable, ICDPManager {\r\n    using SafeMath for uint;\r\n\r\n    uint constant DIGITS = 1e18; // Number of digits used for precision, e.g. when calculating redistribution shares. Equals \"ether\" unit.\r\n    uint constant public MCR = 1100000000000000000; // Minimal collateral ratio.\r\n    uint constant public  CCR = 1500000000000000000; // Critical system collateral ratio. If the total system collateral (TCR) falls below the CCR, Recovery Mode is triggered.\r\n    uint constant public MIN_COLL_IN_USD = 20000000000000000000;\r\n    enum Status { nonExistent, active, closed }\r\n    \r\n    // --- Events --- \r\n    event PoolManagerAddressChanged(address _newPoolManagerAddress);\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n    event CLVTokenAddressChanged(address _newCLVTokenAddress);\r\n    event SortedCDPsAddressChanged(address _sortedCDPsAddress);\r\n\r\n    event CDPCreated(address _user, uint arrayIndex);\r\n    event CDPUpdated(address _user, uint _debt, uint _coll,  uint stake, uint arrayIndex);\r\n    event CDPClosed(address _user);\r\n\r\n    event CollateralAdded(address _user, uint _amountAdded);\r\n    event CollateralWithdrawn(address _user, uint _amountWithdrawn);\r\n    event CLVWithdrawn(address _user, uint _amountWithdrawn);\r\n    event CLVRepayed(address _user, uint _amountRepayed);\r\n    event CollateralRedeemed(address _user, uint exchangedCLV, uint redeemedETH);\r\n\r\n    // --- Connected contract declarations ---\r\n    IPoolManager poolManager;\r\n    address public poolManagerAddress;\r\n\r\n    ICLVToken CLV; \r\n    address public clvTokenAddress;\r\n\r\n    IPriceFeed priceFeed;\r\n    address public priceFeedAddress;\r\n\r\n    // A doubly linked list of CDPs, sorted by their sorted by their collateral ratios\r\n    ISortedCDPs sortedCDPs;\r\n    address public sortedCDPsAddress;\r\n\r\n    // --- Data structures ---\r\n\r\n    // Store the necessary data for a Collateralized Debt Position (CDP)\r\n    struct CDP {\r\n        uint debt;\r\n        uint coll;\r\n        uint stake;\r\n        Status status;\r\n        uint arrayIndex;\r\n    }\r\n    \r\n    bool public recoveryMode;\r\n\r\n    mapping (address => CDP) public CDPs;\r\n\r\n    uint public totalStakes; \r\n\r\n    // snapshot of the value of totalStakes immediately after the last liquidation\r\n    uint public totalStakesSnapshot;  \r\n\r\n    // snapshot of the total collateral in ActivePool and DefaultPool, immediately after the last liquidation.\r\n    uint public totalCollateralSnapshot;    \r\n\r\n    /* L_ETH and L_CLVDebt track the sums of accumulated liquidation rewards per unit staked. During it's lifetime, each stake earns:\r\n\r\n    An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\r\n    A CLVDebt gain  of ( stake * [L_CLVDebt - L_CLVDebt(0)] )\r\n    \r\n    Where L_ETH(0) and L_CLVDebt(0) are snapshots of L_ETH and L_CLVDebt for the active CDP taken at the instant the stake was made */\r\n    uint public L_ETH;     \r\n    uint public L_CLVDebt;    \r\n\r\n    // maps addresses with active CDPs to their RewardSnapshot\r\n    mapping (address => RewardSnapshot) public rewardSnapshots;  \r\n\r\n    // object containing the ETH and CLV snapshots for a given active CDP\r\n    struct RewardSnapshot { uint ETH; uint CLVDebt;}   \r\n\r\n    //array of all active CDP addresses - used to compute “approx hint” for list insertion\r\n    address[] CDPOwners;\r\n\r\n     // --- Modifiers ---\r\n    modifier onlyPoolManager {\r\n        require(_msgSender() == poolManagerAddress, \"CDPManager: Only the poolManager is authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Dependency setters --- \r\n    function setPoolManager(address _poolManagerAddress) public onlyOwner {\r\n        poolManagerAddress = _poolManagerAddress;\r\n        poolManager = IPoolManager(_poolManagerAddress);\r\n        emit PoolManagerAddressChanged(_poolManagerAddress);\r\n    }\r\n\r\n    function setPriceFeed(address _priceFeedAddress) public onlyOwner {\r\n        priceFeedAddress = _priceFeedAddress;\r\n        priceFeed = IPriceFeed(priceFeedAddress);\r\n        emit PriceFeedAddressChanged(_priceFeedAddress);\r\n    }\r\n\r\n    function setCLVToken(address _clvTokenAddress) public onlyOwner {\r\n        clvTokenAddress = _clvTokenAddress;\r\n        CLV = ICLVToken(_clvTokenAddress);\r\n        emit CLVTokenAddressChanged(_clvTokenAddress);\r\n    }\r\n\r\n    function setSortedCDPs(address _sortedCDPsAddress) public onlyOwner {\r\n        sortedCDPsAddress = _sortedCDPsAddress;\r\n        sortedCDPs = ISortedCDPs(_sortedCDPsAddress);\r\n        sortedCDPs.setMaxSize(1000000);\r\n        emit SortedCDPsAddressChanged(_sortedCDPsAddress);\r\n    }\r\n\r\n    // --- Getters ---\r\n    \r\n    function getCDPOwnersCount() public view returns(uint) {\r\n        return CDPOwners.length;\r\n    }\r\n    \r\n    // --- CDP Operations ---\r\n\r\n    // Send ETH as collateral to a CDP\r\n    function addColl(address _user, address _hint) public payable returns (bool) {\r\n        bool isFirstCollDeposit;\r\n    \r\n        if (CDPs[_user].status == Status.nonExistent || CDPs[_user].status == Status.closed ) {\r\n            require(getUSDValue(msg.value) >= MIN_COLL_IN_USD, \r\n                    \"CDPManager: Dollar value of collateral deposit must equal or exceed the minimum\");\r\n            isFirstCollDeposit = true; \r\n        } \r\n\r\n        CDPs[_user].status = Status.active;\r\n\r\n        applyPendingRewards(_user);\r\n\r\n        // Update the CDP's coll and stake\r\n        CDPs[_user].coll = (CDPs[_user].coll).add(msg.value);\r\n        updateStakeAndTotalStakes(_user);\r\n\r\n        uint newICR = getCurrentICR(_user);\r\n\r\n        if (isFirstCollDeposit) {\r\n            sortedCDPs.insert(_user, newICR, _hint, _hint);\r\n             /* push the owner's address to the CDP owners list, and record \r\n            the corresponding array index on the CDP struct */\r\n            CDPs[_user].arrayIndex = CDPOwners.push(_user) - 1;\r\n            emit CDPCreated(_user, CDPs[_user].arrayIndex);\r\n        } else {\r\n            sortedCDPs.reInsert(_user, newICR, _hint, _hint);\r\n        }\r\n\r\n        // Send the received collateral to PoolManager, to forward to ActivePool\r\n        poolManager.addColl.value(msg.value)();\r\n\r\n        checkTCRAndSetRecoveryMode();\r\n        emit CollateralAdded(_user, msg.value);\r\n        emit CDPUpdated(_user, \r\n                        CDPs[_user].debt, \r\n                        CDPs[_user].coll, \r\n                        CDPs[_user].stake,\r\n                        CDPs[_user].arrayIndex);\r\n        return true;\r\n    }\r\n    \r\n    // Withdraw ETH collateral from a CDP\r\n    // TODO: Check re-entrancy protection\r\n    function withdrawColl(uint _amount, address _hint) public returns (bool) {\r\n        checkTCRAndSetRecoveryMode();\r\n\r\n        address user = _msgSender();\r\n        require(CDPs[user].status == Status.active, \"CDPManager: CDP does not exist or is closed\");\r\n       \r\n        applyPendingRewards(user);\r\n        require(CDPs[user].coll >= _amount, \"CDPManager: Insufficient balance for ETH withdrawal\");\r\n        \r\n        uint newColl = CDPs[user].coll.sub(_amount);\r\n        require(getUSDValue(newColl) >= MIN_COLL_IN_USD  || newColl == 0, \r\n                \"CDPManager: Remaining collateral must have $USD value >= 20, or be zero\");\r\n\r\n        uint newICR = getNewICRfromCollDecrease(user, _amount);\r\n        require(recoveryMode == false, \"CDPManager: Collateral withdrawal is not permitted during Recovery Mode\");\r\n        require(newICR >= MCR, \"CDPManager: Insufficient collateral ratio for ETH withdrawal\");\r\n        \r\n        // Update the CDP's coll and stake\r\n        CDPs[user].coll = newColl;\r\n        updateStakeAndTotalStakes(user);\r\n\r\n        if (newColl == 0) { \r\n             closeCDP(user); \r\n        }  else { \r\n        // Update CDP's position in sortedCDPs\r\n        sortedCDPs.reInsert(user, newICR, _hint, _hint);\r\n\r\n        emit CollateralWithdrawn(user, _amount);\r\n        emit CDPUpdated(user, \r\n                        CDPs[user].debt, \r\n                        CDPs[user].coll, \r\n                        CDPs[user].stake,\r\n                        CDPs[user].arrayIndex); \r\n        }\r\n         // Remove _amount ETH from ActivePool and send it to the user\r\n        poolManager.withdrawColl(user, _amount);\r\n\r\n        return true;\r\n    }\r\n    \r\n    // Withdraw CLV tokens from a CDP: mint new CLV to the owner, and increase the debt accordingly\r\n    function withdrawCLV(uint _amount, address _hint) public returns (bool) {\r\n        checkTCRAndSetRecoveryMode();\r\n\r\n        address user = _msgSender();\r\n        \r\n        require(CDPs[user].status == Status.active, \"CDPManager: CDP does not exist or is closed\");\r\n        require(_amount > 0, \"CDPManager: Amount to withdraw must be larger than 0\");\r\n        \r\n        uint newTCR = getNewTCRfromDebtIncrease(_amount);\r\n        uint newICR = getNewICRfromDebtIncrease(user, _amount);\r\n        \r\n        require(recoveryMode == false, \"CDPManager: Debt issuance is not permitted during Recovery Mode\");\r\n        require(newTCR >= CCR, \"CDPManager: a CLV withdrawal that would result in TCR < CCR is not permitted\");\r\n        require(newICR >= MCR, \"CDPManager: Insufficient collateral ratio for CLV withdrawal\");\r\n        \r\n        // Increase the CDP's debt\r\n        CDPs[user].debt = (CDPs[user].debt).add(_amount);\r\n\r\n        // Update CDP's position in sortedCDPs\r\n        sortedCDPs.reInsert(user, newICR, _hint, _hint);\r\n\r\n        // Mint the given amount of CLV to the owner's address and add them to the ActivePool\r\n        poolManager.withdrawCLV(user, _amount);\r\n        \r\n        emit CLVWithdrawn(user, _amount);\r\n        emit CDPUpdated(user, \r\n                        CDPs[user].debt, \r\n                        CDPs[user].coll,  \r\n                        CDPs[user].stake,\r\n                        CDPs[user].arrayIndex); \r\n        return true; \r\n    }\r\n    \r\n    // Repay CLV tokens to a CDP: Burn the repaid CLV tokens, and reduce the debt accordingly\r\n    function repayCLV(uint _amount, address _hint) public returns (bool) {\r\n\r\n        address user = _msgSender();\r\n        require(CDPs[user].status == Status.active, \"CDPManager: CDP does not exist or is closed\");\r\n        require(_amount > 0, \"CDPManager: Repaid amount must be larger than 0\");\r\n       \r\n        require(_amount <= CDPs[user].debt, \"CDPManager: Repaid amount is larger than current debt\");\r\n        require(CLV.balanceOf(user) >= _amount, \"CDPManager: Sender has insufficient CLV balance\");\r\n        // TODO: Maybe allow foreign accounts to repay loans\r\n        \r\n        // Update the CDP's debt\r\n        CDPs[user].debt  = (CDPs[user].debt).sub(_amount);\r\n\r\n        uint newICR = getCurrentICR(user);\r\n        \r\n        // Update CDP's position in sortedCDPs\r\n        sortedCDPs.reInsert(user, newICR, _hint, _hint);\r\n\r\n        // Burn the received amount of CLV from the user's balance, and remove it from the ActivePool\r\n        poolManager.repayCLV(user, _amount);\r\n\r\n        checkTCRAndSetRecoveryMode();\r\n\r\n        emit CLVRepayed(user, _amount);\r\n        emit CDPUpdated(user, \r\n                        CDPs[user].debt, \r\n                        CDPs[user].coll, \r\n                        CDPs[user].stake,\r\n                        CDPs[user].arrayIndex); \r\n        return true;\r\n    }\r\n\r\n    // --- CDP Liquidation functions ---\r\n\r\n    // Closes the CDP of the specified user if its individual collateral ratio is lower than the minimum collateral ratio.\r\n    // TODO: Left public for initial testing. Make internal.\r\n    function liquidate(address _user) public returns (bool) {\r\n        checkTCRAndSetRecoveryMode();\r\n\r\n        require(CDPs[_user].status == Status.active, \"CDPManager: CDP does not exist or is already closed\");\r\n        \r\n        if (recoveryMode == true) {\r\n            liquidateRecoveryMode(_user);\r\n        } else if (recoveryMode == false) {\r\n            liquidateNormalMode(_user);\r\n        }  \r\n    }\r\n    \r\n    function liquidateNormalMode(address _user) internal returns (bool) {\r\n        uint ICR = getCurrentICR(_user);\r\n\r\n        // If ICR < MCR, withdraw any gains from Stability Pool to the CDP, and re-check ICR\r\n        if (ICR < MCR) {\r\n            poolManager.withdrawFromSPtoCDP(_user);\r\n            ICR = getCurrentICR(_user);\r\n        } else {\r\n            return false;\r\n        }\r\n\r\n        // If ICR is now > MCR, update CDP's position in sortedCDPs and return\r\n        if (ICR > MCR) { \r\n            sortedCDPs.reInsert(_user, ICR, _user, _user);\r\n            return false; \r\n        } \r\n    \r\n        // Apply the CDP's rewards and remove stake\r\n        applyPendingRewards(_user);\r\n        removeStake(_user);\r\n\r\n        // Offset as much debt & collateral as possible against the StabilityPool and save the returned remainders\r\n        uint[2] memory remainder = poolManager.offset(CDPs[_user].debt, CDPs[_user].coll);\r\n        uint CLVDebtRemainder = remainder[0];\r\n        uint ETHRemainder = remainder[1];\r\n\r\n        redistributeCollAndDebt(ETHRemainder, CLVDebtRemainder);\r\n        \r\n        closeCDP(_user);\r\n        updateSystemSnapshots();\r\n        return true;\r\n    }\r\n\r\n    function liquidateRecoveryMode(address _user) internal returns (bool) {\r\n        // Withdraw any Stability Pool gains to the CDP\r\n        poolManager.withdrawFromSPtoCDP(_user);\r\n        \r\n        uint ICR = getCurrentICR(_user);\r\n\r\n        // If ICR <= 100%, redistribute the CDP across all active CDPs\r\n        if (ICR <= 1000000000000000000) {\r\n            applyPendingRewards(_user);\r\n            removeStake(_user);\r\n\r\n            // Redistribute entire coll and debt \r\n            uint entireColl = CDPs[_user].coll;\r\n            uint entireDebt = CDPs[_user].debt;\r\n            redistributeCollAndDebt(entireColl, entireDebt);\r\n\r\n            closeCDP(_user);\r\n            updateSystemSnapshots();\r\n\r\n        // if 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\r\n        } else if ((ICR > 1000000000000000000) && (ICR < MCR)) {\r\n            applyPendingRewards(_user);\r\n            removeStake(_user);\r\n            \r\n            // Offset as much debt & collateral as possible against the StabilityPool and save the returned remainders\r\n            uint[2] memory remainder = poolManager.offset(CDPs[_user].debt, CDPs[_user].coll);\r\n            uint CLVDebtRemainder = remainder[0];\r\n            uint ETHRemainder = remainder[1];\r\n\r\n            redistributeCollAndDebt(ETHRemainder, CLVDebtRemainder);\r\n    \r\n            closeCDP(_user);\r\n            updateSystemSnapshots();\r\n\r\n        // If CDP has the lowest ICR and there is CLV in the Stability Pool, only offset it as much as possible (no redistribution)\r\n        } else if ((_user == sortedCDPs.getLast()) && (poolManager.getStabilityPoolCLV() != 0)) {\r\n            applyPendingRewards(_user);\r\n            removeStake(_user);\r\n\r\n            // Offset as much debt & collateral as possible against the StabilityPool and save the returned remainders\r\n            uint[2] memory remainder = poolManager.offset(CDPs[_user].debt, CDPs[_user].coll);\r\n            uint CLVDebtRemainder = remainder[0];\r\n            uint ETHRemainder = remainder[1];\r\n\r\n            // Close the CDP and update snapshots if the CDP was completely offset against CLV in Stability Pool\r\n            if (CLVDebtRemainder == 0) {\r\n                closeCDP(_user);\r\n                updateSystemSnapshots();\r\n            }\r\n\r\n            // If loan can not be entirely offset, leave the CDP active, with a reduced coll and debt, and corresponding new stake.\r\n            if (CLVDebtRemainder > 0) {\r\n                // Update system snapshots, excluding the reduced collateral that remains in the CDP\r\n                updateSystemSnapshots_excludeCollRemainder(ETHRemainder);\r\n                \r\n                // Give the loan a new reduced coll and debt, then update stake and totalStakes\r\n                CDPs[_user].coll = ETHRemainder;\r\n                CDPs[_user].debt = CLVDebtRemainder;\r\n                updateStakeAndTotalStakes(_user);\r\n               \r\n                uint newICR = getCurrentICR(_user);\r\n                // TODO: use getApproxHint() here? Analyze gas usage and find size of list at which getApproxHint() is a net gas-saver\r\n                sortedCDPs.reInsert(_user, newICR, _user, _user);\r\n\r\n                emit CDPUpdated(_user, \r\n                    CDPs[_user].debt, \r\n                    CDPs[_user].coll, \r\n                    CDPs[_user].stake,\r\n                    CDPs[_user].arrayIndex);\r\n            }\r\n        } \r\n        checkTCRAndSetRecoveryMode();\r\n    }\r\n\r\n    // Closes a maximum number of n multiple under-collateralized CDPs, starting from the one with the lowest collateral ratio\r\n    // TODO: Should  be synchronized with PriceFeed and called every time the price is updated\r\n    function liquidateCDPs(uint n) public returns (bool) {  \r\n        checkTCRAndSetRecoveryMode();\r\n\r\n        if (recoveryMode == true) {\r\n            uint i;\r\n            while (i < n) {\r\n                address user = sortedCDPs.getLast();\r\n                uint collRatio = getCurrentICR(user);\r\n                // attempt to close CDP\r\n                liquidate(user);\r\n                /* Break loop if the system has left recovery mode and all active CDPs are \r\n                above the MCR, or if the loop reaches the first CDP in the sorted list  */\r\n                if ((recoveryMode == false && collRatio >= MCR) || (user == sortedCDPs.getFirst())) { break; }\r\n                i++;\r\n            }\r\n            return true;\r\n\r\n        } else if (recoveryMode == false) {\r\n            uint i;\r\n            while (i < n) {\r\n                address user = sortedCDPs.getLast();\r\n                uint collRatio = getCurrentICR(user);\r\n\r\n                // Close CDPs if it is under-collateralized\r\n                if (collRatio < MCR) {\r\n                    liquidate(user);\r\n                } else break;\r\n                \r\n                // Break loop if you reach the first CDP in the sorted list \r\n                if (user == sortedCDPs.getFirst()) { break ;}\r\n                i++;\r\n            }       \r\n        }\r\n        return true;\r\n    }\r\n            \r\n    /* Send _amount CLV to the system and redeem the corresponding amount of collateral from as many CDPs as are needed to fill the redemption\r\n     request.  Applies pending rewards to a CDP before reducing its debt and coll.\r\n    \r\n    Note that if _amount is very large, this function can run out of gas. This can be easily avoided by splitting the total _amount\r\n    in appropriate chunks and calling the function multiple times.\r\n    \r\n    TODO: Maybe also use the default pool for redemptions\r\n    TODO: Levy a redemption fee (and maybe also impose a rate limit on redemptions) */\r\n    function redeemCollateral(uint _CLVamount, address _hint) public returns (bool) {\r\n        require(CLV.balanceOf(_msgSender()) >= _CLVamount, \"CDPManager: Sender has insufficient balance\");\r\n        uint exchangedCLV;\r\n        uint redeemedETH;\r\n\r\n        // Loop through the CDPs starting from the one with lowest collateral ratio until _amount of CLV is exchanged for collateral\r\n        while (exchangedCLV < _CLVamount) {\r\n\r\n            address currentCDPuser = sortedCDPs.getLast();\r\n            uint collRatio = getCurrentICR(currentCDPuser);\r\n            uint price = priceFeed.getPrice();\r\n            uint activeDebt = poolManager.getActiveDebt();\r\n\r\n            // Break the loop if there is no more active debt to cancel with the received CLV\r\n            if (activeDebt == 0) break;   \r\n            \r\n            // Close CDPs along the way that turn out to be under-collateralized\r\n            if (collRatio < MCR) {\r\n                liquidate(currentCDPuser);\r\n            }\r\n            else {\r\n                applyPendingRewards(currentCDPuser);\r\n\r\n                // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the current CDP \r\n                uint CLVLot = DeciMath.getMin(_CLVamount.sub(exchangedCLV), CDPs[currentCDPuser].debt);\r\n                uint ETHLot = DeciMath.accurateMulDiv(CLVLot, DIGITS, price);\r\n                    \r\n                // Decrease the debt and collateral of the current CDP according to the lot and corresponding ETH to send\r\n                CDPs[currentCDPuser].debt = (CDPs[currentCDPuser].debt).sub(CLVLot);\r\n                CDPs[currentCDPuser].coll = (CDPs[currentCDPuser].coll).sub(ETHLot);\r\n                \r\n                uint newCollRatio = getCurrentICR(currentCDPuser);\r\n\r\n                // Burn the calculated lot of CLV and send the corresponding ETH to _msgSender()\r\n                poolManager.redeemCollateral(_msgSender(), CLVLot, ETHLot);\r\n\r\n                // Update the sortedCDPs list and the redeemed amount\r\n                sortedCDPs.reInsert(currentCDPuser, newCollRatio, _hint, _hint); \r\n                emit CDPUpdated(\r\n                                currentCDPuser, \r\n                                CDPs[currentCDPuser].debt, \r\n                                CDPs[currentCDPuser].coll, \r\n                                CDPs[currentCDPuser].stake,\r\n                                CDPs[currentCDPuser].arrayIndex);\r\n                exchangedCLV = exchangedCLV.add(CLVLot);  \r\n                redeemedETH = redeemedETH.add(ETHLot);\r\n            }\r\n        }\r\n        emit CollateralRedeemed(_msgSender(), exchangedCLV, redeemedETH);\r\n    } \r\n\r\n    // --- Helper functions ---\r\n\r\n     /* getApproxHint() - return address of a CDP that is, on average, (length / numTrials) positions away in the \r\n    sortedCDPs list from the correct insert position of the CDP to be inserted. \r\n    \r\n    Note: The output address is worst-case O(n) positions away from the correct insert position, however, the function \r\n    is probabilistic. Input can be tuned to guarantee results to a high degree of confidence, e.g:\r\n\r\n    Submitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the ouput address will \r\n    be <= sqrt(length) positions away from the correct insert position.\r\n   \r\n    Note on the use of block.timestamp for random number generation: it is known to be gameable by miners. However, no value \r\n    transmission depends on getApproxHint() - it is only used to generate hints for efficient list traversal. In this case, \r\n    there is no profitable exploit.\r\n    */\r\n    function getApproxHint(uint CR, uint numTrials) public view returns(address) {\r\n        require (CDPOwners.length >= 1, \"CDPManager: sortedList must not be empty\");\r\n        address hintAddress = sortedCDPs.getLast();\r\n        uint closestICR = getCurrentICR(hintAddress);\r\n        uint diff = getAbsoluteDifference(CR, closestICR);\r\n        uint i = 1;\r\n\r\n        while (i < numTrials) {\r\n            uint arrayIndex = getRandomArrayIndex(block.timestamp.add(i), CDPOwners.length);\r\n            address currentAddress = CDPOwners[arrayIndex];\r\n            uint currentICR = getCurrentICR(currentAddress);\r\n\r\n            // check if abs(current - CR) > abs(closest - CR), and update closest if current is closer\r\n            uint currentDiff = getAbsoluteDifference(currentICR, CR);\r\n\r\n            if (currentDiff < diff) {\r\n                closestICR = currentICR;\r\n                diff = currentDiff;\r\n                hintAddress = currentAddress;\r\n            }\r\n            i++;\r\n        }\r\n    return hintAddress;\r\n}\r\n\r\n    function getAbsoluteDifference(uint a, uint b) internal view returns(uint) {\r\n        if (a >= b) {\r\n            return a.sub(b);\r\n        } else if (a < b) {\r\n            return b.sub(a);\r\n        }\r\n    }\r\n\r\n    // Convert input to pseudo-random uint in range [0, arrayLength - 1]\r\n    function getRandomArrayIndex(uint input, uint _arrayLength) internal view returns(uint) {\r\n        uint randomIndex = uint256(keccak256(abi.encodePacked(input))) % (_arrayLength);\r\n        return randomIndex;\r\n   }\r\n\r\n    // Return the current collateral ratio (ICR) of a given CDP. Takes pending coll/debt rewards into account.\r\n    function getCurrentICR(address _user) public view returns(uint) {\r\n        uint pendingETHReward = computePendingETHReward(_user);\r\n        uint pendingCLVDebtReward = computePendingCLVDebtReward(_user);\r\n       \r\n        uint currentETH = (CDPs[_user].coll).add(pendingETHReward);\r\n        uint currentCLVDebt = (CDPs[_user].debt).add(pendingCLVDebtReward);\r\n        \r\n        uint ICR = computeICR(currentETH, currentCLVDebt);\r\n        return ICR;\r\n    }\r\n\r\n    /* Compute the new collateral ratio, considering the collateral to be removed. Takes pending coll/debt \r\n    rewards into account. */\r\n    function getNewICRfromCollDecrease(address _user, uint _collDecrease) view internal returns(uint) {\r\n        uint pendingETHReward = computePendingETHReward(_user);\r\n        uint pendingCLVDebtReward = computePendingCLVDebtReward(_user);\r\n\r\n        uint currentETH = (CDPs[_user].coll).add(pendingETHReward);\r\n        uint currentCLVDebt = (CDPs[_user].debt).add(pendingCLVDebtReward);\r\n\r\n        uint newColl = currentETH.sub(_collDecrease);\r\n        \r\n        return computeICR(newColl, currentCLVDebt);\r\n    }\r\n\r\n    /* Compute the new collateral ratio, considering the debt to be added.Takes pending coll/debt rewards into account. */\r\n    function getNewICRfromDebtIncrease(address _user, uint _debtIncrease) view internal returns(uint) {\r\n        uint pendingETHReward = computePendingETHReward(_user);\r\n        uint pendingCLVDebtReward = computePendingCLVDebtReward(_user);\r\n\r\n        uint currentETH = (CDPs[_user].coll).add(pendingETHReward);\r\n        uint currentCLVDebt = (CDPs[_user].debt).add(pendingCLVDebtReward);\r\n\r\n        uint newCLVDebt = currentCLVDebt.add(_debtIncrease);\r\n\r\n        return computeICR(currentETH, newCLVDebt);\r\n    } \r\n\r\n    function computeICR(uint coll, uint debt) view internal returns(uint) {\r\n        uint price = priceFeed.getPrice();\r\n        // Check if the total debt is higher than 0, to avoid division by 0\r\n        if (debt > 0) {\r\n            // uint newCollRatio = DeciMath.accurateMulDiv(coll, price, debt);\r\n            uint ratio = DeciMath.div_toDuint(coll, debt);\r\n            uint newCollRatio = DeciMath.decMul(price, ratio);\r\n            return newCollRatio;\r\n        }\r\n        // Return the maximal value for uint256 if the CDP has a debt of 0\r\n        else {\r\n            return 2**256 - 1; \r\n        }\r\n    }\r\n\r\n    // Add the user's coll and debt rewards earned from liquidations, to their CDP\r\n    function applyPendingRewards(address _user) internal returns(bool) {\r\n        require(CDPs[_user].status == Status.active, \"CDPManager: user must have an active CDP\");\r\n        \r\n        // Compute pending rewards\r\n        uint pendingETHReward = computePendingETHReward(_user);\r\n        uint pendingCLVDebtReward = computePendingCLVDebtReward(_user);\r\n\r\n        // Apply pending rewards\r\n        CDPs[_user].coll = CDPs[_user].coll.add(pendingETHReward);\r\n        CDPs[_user].debt = CDPs[_user].debt.add(pendingCLVDebtReward);\r\n\r\n        // Tell PM to transfer from DefaultPool to ActivePool when user claims rewards.\r\n        poolManager.applyPendingRewards(pendingCLVDebtReward, pendingETHReward);\r\n\r\n        // Update user's reward snapshot to reflect current values\r\n        rewardSnapshots[_user].ETH = L_ETH;\r\n        rewardSnapshots[_user].CLVDebt = L_CLVDebt;\r\n        return true;\r\n    }\r\n\r\n    // Get the user's pending accumulated ETH reward, earned by its stake\r\n    function computePendingETHReward(address _user) internal view returns(uint) {\r\n        uint stake = CDPs[_user].stake;\r\n        uint snapshotETH = rewardSnapshots[_user].ETH;\r\n\r\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\r\n        uint pendingETHReward = DeciMath.mul_uintByDuint(stake, rewardPerUnitStaked);\r\n        return pendingETHReward;\r\n    }\r\n\r\n     // Get the user's pending accumulated CLV reward, earned by its stake\r\n    function computePendingCLVDebtReward(address _user) internal view returns(uint) {\r\n        uint stake =  CDPs[_user].stake;\r\n        uint snapshotETH = rewardSnapshots[_user].CLVDebt;\r\n\r\n        uint rewardPerUnitStaked = L_CLVDebt.sub(snapshotETH);\r\n        uint pendingCLVDebtReward = DeciMath.mul_uintByDuint(stake, rewardPerUnitStaked);\r\n        return pendingCLVDebtReward;\r\n    }\r\n\r\n    // Remove use's stake from the totalStakes sum, and set their stake to 0\r\n    function removeStake(address _user) internal returns (bool) {\r\n        uint stake = CDPs[_user].stake;\r\n        totalStakes = totalStakes.sub(stake);\r\n        CDPs[_user].stake = 0;\r\n    }\r\n\r\n    // Update user's stake based on their latest collateral value\r\n    function updateStakeAndTotalStakes(address _user) internal returns(bool) {\r\n        uint oldStake = CDPs[_user].stake;\r\n        totalStakes = totalStakes.sub(oldStake);\r\n       \r\n        uint newStake = computeNewStake(CDPs[_user].coll);\r\n\r\n        CDPs[_user].stake = newStake;\r\n        totalStakes = totalStakes.add(newStake);\r\n        return true;\r\n    }\r\n\r\n    function computeNewStake(uint _coll) internal view returns (uint) {\r\n        uint stake;\r\n        if (totalCollateralSnapshot == 0) {\r\n            stake = _coll;\r\n        } else {\r\n            uint ratio = DeciMath.div_toDuint(totalStakesSnapshot, totalCollateralSnapshot);\r\n            stake = DeciMath.mul_uintByDuint(_coll, ratio);\r\n        }\r\n     return stake;\r\n    }\r\n\r\n    function redistributeCollAndDebt(uint _coll, uint _debt) internal returns (bool) {\r\n        if (_debt > 0) {\r\n            if (totalStakes > 0) {\r\n                /*If debt could not be offset entirely, add the coll and debt rewards-per-unit-staked \r\n                to the running totals. */\r\n                uint ETHRewardPerUnitStaked = DeciMath.div_toDuint(_coll, totalStakes);\r\n                uint CLVDebtRewardPerUnitStaked = DeciMath.div_toDuint(_debt, totalStakes);\r\n                \r\n                L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\r\n                L_CLVDebt = L_CLVDebt.add(CLVDebtRewardPerUnitStaked);\r\n            }\r\n            // Transfer coll and debt from ActivePool to DefaultPool\r\n            poolManager.liquidate(_debt, _coll);\r\n        } \r\n    }\r\n\r\n    function closeCDP(address _user) internal returns (bool) {\r\n        CDPs[_user].status = Status.closed;\r\n        \r\n        sortedCDPs.remove(_user);\r\n        removeCDPOwner(_user);\r\n\r\n        emit CDPClosed(_user);\r\n        return true;\r\n    }\r\n\r\n    // Update the snapshots of system stakes & system collateral\r\n    function updateSystemSnapshots() internal returns (bool) {\r\n        totalStakesSnapshot = totalStakes;\r\n\r\n        /* The total collateral snapshot is the sum of all active collateral and all pending rewards\r\n       (ActivePool ETH + DefaultPool ETH), immediately after the liquidation occurs. */\r\n        uint activeColl = poolManager.getActiveColl();\r\n        uint liquidatedColl = poolManager.getLiquidatedColl();\r\n        totalCollateralSnapshot = activeColl.add(liquidatedColl);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Updates snapshots of system stakes and system collateral, excluding a given collateral remainder from the calculation\r\n     function updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal returns (bool) {\r\n        totalStakesSnapshot = totalStakes;\r\n\r\n        /* The total collateral snapshot is the sum of all active collateral and all pending rewards\r\n       (ActivePool ETH + DefaultPool ETH), immediately after the liquidation occurs. */\r\n        uint activeColl = poolManager.getActiveColl();\r\n        uint liquidatedColl = poolManager.getLiquidatedColl();\r\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\r\n\r\n        return true;\r\n    }\r\n  \r\n     /* Remove a CDP owner from the CDPOwners array, preserving array length but not order. Deleting owner 'B' does the following: \r\n    [A B C D E] => [A E C D], and updates E's CDP struct to point to its new array index. */\r\n    function removeCDPOwner(address _user) internal returns(bool) {\r\n        require(CDPs[_user].status == Status.closed, \"CDPManager: CDP is still active\");\r\n\r\n        uint index = CDPs[_user].arrayIndex;   \r\n        address addressToMove = CDPOwners[CDPOwners.length - 1];\r\n       \r\n        CDPOwners[index] = addressToMove;   \r\n        CDPs[addressToMove].arrayIndex = index;   \r\n        CDPOwners.length--;  \r\n    }\r\n\r\n    // Get the dollar value of collateral, as a duint\r\n    function getUSDValue(uint _coll) internal view returns (uint) {\r\n        return DeciMath.decMul(priceFeed.getPrice(), _coll);\r\n    }\r\n\r\n    function getNewTCRfromDebtIncrease(uint _debtIncrease) public view returns (uint) {\r\n        uint activeColl = poolManager.getActiveColl();\r\n        uint activeDebt = poolManager.getActiveDebt();\r\n        uint liquidatedColl = poolManager.getLiquidatedColl();\r\n        uint closedDebt = poolManager.getClosedDebt();\r\n\r\n        uint totalCollateral = activeColl.add(liquidatedColl);\r\n        uint newTotalDebt = activeDebt.add(closedDebt).add(_debtIncrease);\r\n\r\n        uint newTCR = computeICR(totalCollateral, newTotalDebt);\r\n        \r\n        return newTCR;\r\n    }\r\n\r\n    function checkTCRAndSetRecoveryMode() public returns (bool){\r\n        uint activeColl = poolManager.getActiveColl();\r\n        uint activeDebt = poolManager.getActiveDebt();\r\n        uint liquidatedColl = poolManager.getLiquidatedColl();\r\n        uint closedDebt = poolManager.getClosedDebt();\r\n\r\n        uint totalCollateral  = activeColl.add(liquidatedColl);\r\n        uint totalDebt = activeDebt.add(closedDebt);\r\n\r\n        uint TCR = computeICR(totalCollateral, totalDebt);\r\n        \r\n        /* if TCR falls below 150%, trigger recovery mode. If TCR rises above 150%, \r\n        disable recovery mode */\r\n        if ((TCR < 1500000000000000000) && (recoveryMode == false)) {\r\n            recoveryMode = true;\r\n        } else if ((TCR >= 1500000000000000000) && (recoveryMode == true)) {\r\n            recoveryMode = false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}"
    },
    "contracts/Interfaces/ICDPManager.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\n// Common interface for the CDP Manager.\r\ninterface ICDPManager {\r\n    // --- Events ---\r\n    event PoolManagerAddressChanged(address _newPoolManagerAddress);\r\n\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n\r\n    event CLVTokenAddressChanged(address _newCLVTokenAddress);\r\n\r\n    event SortedCDPsAddressChanged(address _sortedCDPsAddress);\r\n\r\n    event CDPCreated(address _user, uint arrayIndex);\r\n\r\n    event CDPUpdated(address _user, uint _debt, uint _coll, uint stake, uint arrayIndex);\r\n\r\n    event CDPClosed(address _user);\r\n\r\n    event CollateralAdded(address _user, uint _amountAdded);\r\n\r\n    event CollateralWithdrawn(address _user, uint _amountWithdrawn);\r\n\r\n    event CLVWithdrawn(address _user, uint _amountWithdrawn);\r\n\r\n    event CLVRepayed(address _user, uint _amountRepayed);\r\n\r\n    event CollateralRedeemed(address _user, uint exchangedCLV, uint redeemedETH);\r\n\r\n    // --- Functions ---\r\n    function setPoolManager(address _poolManagerAddress) external;\r\n\r\n    function setPriceFeed(address _priceFeedAddress) external;\r\n\r\n    function setCLVToken(address _clvTokenAddress) external;\r\n\r\n    function setSortedCDPs(address _sortedCDPsAddress) external;\r\n\r\n    function getCDPOwnersCount() external view returns(uint);\r\n\r\n    function getCurrentICR(address _user) external view returns(uint);\r\n\r\n    function getApproxHint(uint CR, uint numTrials) external view returns(address);\r\n\r\n    function addColl(address _user, address _hint) external payable returns(bool);\r\n\r\n    function withdrawColl(uint _amount, address _hint) external returns(bool);\r\n\r\n    function withdrawCLV(uint _amount, address _hint) external returns(bool);\r\n\r\n    function repayCLV(uint _amount, address _hint) external returns(bool);\r\n\r\n    function liquidate(address _user) external returns(bool);\r\n\r\n    function liquidateCDPs(uint _n) external returns(bool);\r\n\r\n    function checkTCRAndSetRecoveryMode() external returns(bool);\r\n\r\n    function redeemCollateral(uint _CLVAmount, address _hint) external returns(bool);\r\n\r\n    function getNewTCRfromDebtIncrease(uint _debtIncrease) external view returns (uint);\r\n}"
    },
    "contracts/Interfaces/ICLVToken.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\ninterface ICLVToken { \r\n    // --- Events ---\r\n    event PoolManagerAddressChanged( address _newPoolManagerAddress);\r\n\r\n    event CLVTokenBalanceUpdated(address _user, uint _amount);\r\n\r\n    // --- Functions ---\r\n    function setPoolManagerAddress(address _poolManagerAddress) external;\r\n\r\n    function mint(address _account, uint256 _amount) external returns(bool);\r\n\r\n    function burn(address _account, uint256 _amount) external returns(bool);\r\n\r\n    function sendToPool(address _sender,  address poolAddress, uint256 _amount) external returns(bool);\r\n\r\n    function returnFromPool(address poolAddress, address user, uint256 _amount ) external returns(bool);\r\n\r\n    function totalSupply() external view returns(uint256);\r\n\r\n    function balanceOf(address account) external view returns(uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns(bool);\r\n\r\n    function allowance(address owner, address spender) external view returns(uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns(bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns(bool);\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns(bool);\r\n}"
    },
    "contracts/Interfaces/IPriceFeed.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\ninterface IPriceFeed { \r\n    // --- Events ---\r\n    event PriceUpdated(uint _newPrice);\r\n\r\n    event CDPManagerAddressChanged(address _cdpManagerAddress);\r\n\r\n    // --- Functions ---\r\n    function setCDPManagerAddress(address _cdpManagerAddress) external;\r\n\r\n    function setPrice(uint _price) external returns(bool);\r\n        \r\n    function getPrice() external view returns(uint);\r\n}\r\n"
    },
    "contracts/Interfaces/ISortedCDPs.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\n// Common interface for the SortedCDPs Doubly Linked List.\r\ninterface ISortedCDPs {\r\n// --- Events ---\r\nevent SortedCDPsAddressChanged(address _sortedDoublyLLAddress);\r\n\r\n// --- Functions ---\r\n    function setCDPManager(address _CDPManagerAddress) external;\r\n\r\n    function setMaxSize(uint256 _size) external;\r\n\r\n    function insert(address _id, uint256 _ICR, address _prevId, address _nextId) external;\r\n\r\n    function remove(address _id) external;\r\n\r\n    function reInsert(address _id, uint256 _newICR, address _prevId, address _nextId) external;\r\n\r\n    function contains(address _id) external view returns (bool);\r\n\r\n    function isFull() external view returns (bool);\r\n\r\n    function isEmpty() external view returns (bool);\r\n\r\n    function getSize() external view returns (uint256);\r\n\r\n    function getMaxSize() external view returns (uint256);\r\n\r\n    function getFirst() external view returns (address);\r\n\r\n    function getLast() external view returns (address);\r\n\r\n    function getNext(address _id) external view returns (address);\r\n\r\n    function getPrev(address _id) external view returns (address);\r\n\r\n    function validInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (bool);\r\n\r\n    function findInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (address, address);\r\n}"
    },
    "contracts/Interfaces/IPoolManager.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\n// Common interface for the ETH/CLV pools.\r\ninterface IPoolManager {\r\n     // --- Events ---\r\n    event CDPManagerAddressChanged(address _newCDPManagerAddress);\r\n\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n\r\n    event CLVTokenAddressChanged(address _newCLVTokenAddress);\r\n\r\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\r\n\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n\r\n    event UserSnapshotUpdated(uint _CLV, uint _ETH);\r\n\r\n    event S_CLVUpdated(uint _S_CLV);\r\n\r\n    event S_ETHUpdated(uint _S_ETH);\r\n\r\n    event UserDepositChanged(address _user, uint _amount);\r\n\r\n    event OverstayPenaltyClaimed(address claimant, uint claimantReward, address depositor, uint remainder);\r\n\r\n    // --- Functions ---\r\n    function setCDPManagerAddress(address _cdpManagerAddress) external;\r\n\r\n    function setPriceFeed(address _priceFeedAddress) external;\r\n\r\n    function setCLVToken(address _CLVAddress) external;\r\n\r\n    function setStabilityPool(address _stabilityPoolAddress) external;\r\n\r\n    function setActivePool(address _activePoolAddress) external;\r\n\r\n    function setDefaultPool(address _defaultPoolAddress) external;\r\n    \r\n    function getBalance() external view returns(uint);\r\n    \r\n    function getActiveDebt() external view returns(uint);\r\n    \r\n    function getActiveColl() external view returns(uint);\r\n    \r\n    function getClosedDebt() external view returns (uint);\r\n    \r\n    function getLiquidatedColl() external view returns(uint);\r\n\r\n    function getStabilityPoolCLV() external view returns (uint);\r\n\r\n    function addColl() external payable returns(bool);\r\n\r\n    function withdrawColl(address _account, uint _ETH) external returns (bool);\r\n\r\n    function withdrawCLV(address _account, uint _CLV) external returns(bool);\r\n    \r\n    function repayCLV(address _account, uint _CLV) external returns(bool);\r\n\r\n    function liquidate(uint _CLV, uint _ETH) external returns(bool);\r\n  \r\n    function applyPendingRewards(uint _CLV, uint _ETH) external returns(bool);\r\n\r\n    function redeemCollateral(address _account, uint _CLV, uint _ETH) external returns(bool);\r\n\r\n    // --- StabilityPool Functions ---\r\n    function provideToSP(uint _amount) external returns(bool);\r\n\r\n    function withdrawFromSP(uint _amount) external returns(bool);\r\n\r\n    function withdrawFromSPtoCDP(address _user) external returns(bool);\r\n\r\n    function withdrawPenaltyFromSP(address _address) external returns(bool);\r\n\r\n    function offset(uint _debt, uint _coll) external payable returns(uint[2] memory);\r\n}"
    },
    "contracts/DeciMath.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@nomiclabs/buidler/console.sol\";\r\n\r\nlibrary DeciMath {\r\n    /* \r\n    DeciMath functions use the concept of a 'duint':\r\n    \r\n    A duint is a uint representation of an 18DP decimal number. The right-most \r\n    18 digits correspond to the mantissa, i.e. the digits after the decimal point. \r\n\r\n    Examples:\r\n       1000000000000000000   represents 1\r\n       5432100000000000000   represents 5.4321\r\n               34560000000   represents 0.00000003456\r\n     370000000000000000000   represents 370\r\n                         1   represents 1e-18\r\n\r\n     etc. \r\n    */\r\n\r\n    uint constant _1E18 = 10**18;\r\n    uint constant _1E17 = 10**17;\r\n    uint constant _5E17 = 5*(10**17);\r\n\r\n    // --- Accurate decimal math functions ---\r\n\r\n    /* Accurately calculate (x * y) / z. Converts all arguments to 'duints', performs \r\n    calculations, then converts the result back to uint before returning. */\r\n    function accurateMulDiv(uint x, uint y, uint z) public pure returns (uint fraction) {\r\n        require( z!= 0, \"DeciMath: can not divide by zero\");\r\n    // convert all uint to duint\r\n        uint x_duint = toDuint(x);\r\n        uint y_duint = toDuint(y);\r\n        uint z_duint = toDuint(z);\r\n\r\n        //  (x * y).  If y is guaranteed to be an integer (i.e. not duint) could use normalMul(x_duint, y) here to save gas.\r\n        uint prod_duint = decMul(x_duint, y_duint); \r\n        // (x* y) / z\r\n        uint res_duint = decDiv(prod_duint, z_duint);   \r\n\r\n        // convert result back to uint\r\n        uint result = fromDuint(res_duint);\r\n\r\n        return result;\r\n    }\r\n\r\n    // Accurately divides one 'duint' by another. Returns a 'duint'\r\n    function decDiv(uint x, uint y) public pure returns (uint quotient) {\r\n        uint prod_x_1E18 = SafeMath.mul(x, _1E18);\r\n        uint half_y = SafeMath.div(y, 2);\r\n\r\n        quotient = SafeMath.div(SafeMath.add( prod_x_1E18, half_y), y);\r\n        return quotient;\r\n    }\r\n\r\n     // Accurately multiplies two 'duints'. Returns a 'duint'\r\n    function decMul(uint x, uint y) public pure returns (uint prod) {\r\n        uint prod_xy = SafeMath.mul(x, y);\r\n       \r\n        prod = SafeMath.div(SafeMath.add(prod_xy, _5E17), _1E18 );\r\n        \r\n        return prod;\r\n    }\r\n\r\n    // Accurately divides one uint by another. Returns a 'duint'\r\n    function div_toDuint(uint x, uint y) public pure returns (uint quotient) {\r\n        uint x_duint = toDuint(x);\r\n        uint y_duint = toDuint(y);\r\n\r\n        quotient = decDiv(x_duint, y_duint);\r\n        return quotient;\r\n    }\r\n\r\n    // Accurately multiply one uint by a 'duint'. Returns a uint.\r\n    function mul_uintByDuint( uint x, uint y_duint)public pure returns (uint prod) {\r\n        uint x_duint = toDuint(x);\r\n\r\n        uint prod_duint = decMul(x_duint, y_duint);\r\n        uint prod = fromDuint(prod_duint);\r\n\r\n        return prod;\r\n    }\r\n\r\n    function mul_uintByDuint_roundUp( uint x, uint y_duint)public pure returns (uint prod) {\r\n        uint x_duint = toDuint(x);\r\n\r\n        uint prod_duint = decMul(x_duint, y_duint);\r\n        uint prod = fromDuint_roundUp(prod_duint);\r\n\r\n        return prod;\r\n    }\r\n\r\n     // --- Helpers. Convert to and from duints ---\r\n\r\n    function toDuint(uint integer) public pure returns(uint) {\r\n        return SafeMath.mul(integer, _1E18);\r\n    }\r\n\r\n    function fromDuint(uint duint) public pure returns(uint) {\r\n        // rounding: always round down\r\n        return SafeMath.div(duint, _1E18);\r\n    }\r\n\r\n     function fromDuint_roundUp(uint duint) public pure returns(uint) {\r\n        // rounding: common rounding.\r\n        uint integer;\r\n        integer =  SafeMath.div(duint, _1E18) + 1;  // round up\r\n        return integer;\r\n    }\r\n\r\n    function fromDuint_commonRounding(uint duint) public pure returns(uint) {\r\n        // rounding: common rounding. If first mantissa digit >=5 round up, else round down.\r\n        uint integer;\r\n        uint firstDecimalDigit = SafeMath.div(duint % _1E18, _1E17); // grab 18th digit from-right\r\n        \r\n        if (firstDecimalDigit >= 5 ){\r\n            integer =  SafeMath.div(duint, _1E18) + 1;  // round up\r\n            return integer;\r\n        } else if (firstDecimalDigit < 5 ) {\r\n            integer =  SafeMath.div(duint, _1E18); // round down\r\n            return integer;\r\n        }\r\n    }\r\n\r\n     // --- Normal Solidity multiplication and floor division ---\r\n    function normalDiv(uint a, uint b) public pure returns(uint) {\r\n        return SafeMath.div(a, b);\r\n    }\r\n\r\n    function normalMul(uint a, uint b) public pure returns(uint) {\r\n        return SafeMath.mul(a, b);\r\n    }  \r\n\r\n    // --- Normal min function ---\r\n    function getMin(uint a, uint b) public pure returns(uint) {\r\n        if (a <= b) return a;\r\n        else return b;\r\n    }\r\n}\r\n"
    },
    "contracts/CLVToken.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\nimport \"./Interfaces/ICLVToken.sol\";\r\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./CLVTokenData.sol\";\r\nimport \"@nomiclabs/buidler/console.sol\";\r\n\r\ncontract CLVToken is IERC20, ICLVToken, Ownable {\r\n    using SafeMath for uint256;\r\n    \r\n    event PoolManagerAddressChanged( address _newPoolManagerAddress);\r\n    event CLVTokenBalanceUpdated(address _user, uint _amount);\r\n\r\n    address public poolManagerAddress;\r\n\r\n    uint256 public _totalSupply;\r\n\r\n    CLVTokenData clvTokenData;\r\n    address public tokenDataAddress;\r\n\r\n    constructor() public {\r\n        clvTokenData = new CLVTokenData();\r\n        tokenDataAddress = address(clvTokenData);\r\n    }    \r\n\r\n     modifier onlyPoolManager {\r\n        require(_msgSender() == poolManagerAddress, \"CLVToken: Only the pool is authorized\");\r\n        _;\r\n    }\r\n\r\n    function setPoolManagerAddress(address _poolManagerAddress) public onlyOwner {\r\n        poolManagerAddress =  _poolManagerAddress;\r\n        emit PoolManagerAddressChanged(_poolManagerAddress);\r\n    }\r\n\r\n    function mint(address _account, uint256 _amount) public onlyPoolManager returns (bool) {\r\n        _mint(_account, _amount);\r\n        emit CLVTokenBalanceUpdated(_account, _amount);\r\n        return true;\r\n    }\r\n    \r\n    function burn(address _account, uint256 _amount) public onlyPoolManager returns (bool) {\r\n        _burn(_account, _amount);\r\n         emit CLVTokenBalanceUpdated(_account, _amount);\r\n        return true;\r\n    }\r\n    \r\n    function sendToPool(address _sender,  address poolAddress, uint256 _amount) public onlyPoolManager returns (bool) {\r\n        _transfer(_sender, poolAddress, _amount);\r\n         emit CLVTokenBalanceUpdated(poolAddress, _amount);\r\n        return true;\r\n    }\r\n    \r\n    function returnFromPool(address poolAddress, address user, uint256 _amount ) public onlyPoolManager returns (bool) {\r\n        _transfer(poolAddress, user, _amount);\r\n        emit CLVTokenBalanceUpdated(poolAddress, _amount);\r\n        return true;\r\n    }\r\n\r\n   // --- OPENZEPPELIN ERC20 FUNCTIONALITY ---\r\n\r\n   /**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\n   \r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        uint balance = clvTokenData.getBalance(account); \r\n        return balance; \r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return clvTokenData.getAllowance(owner, spender);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint newAllowance = clvTokenData.getAllowance(sender, _msgSender()).sub(amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), newAllowance);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        uint newAllowance = clvTokenData.getAllowance(_msgSender(),spender).add(addedValue);\r\n        _approve(_msgSender(), spender, newAllowance);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        uint newAllowance = clvTokenData.getAllowance(_msgSender(), spender).sub(subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, newAllowance);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        clvTokenData.subFromBalance(sender, amount);\r\n        clvTokenData.addToBalance(recipient, amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        clvTokenData.addToBalance(account, amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        clvTokenData.subFromBalance(account, amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        clvTokenData.setAllowance(owner, spender, amount);\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        uint newAllowance = clvTokenData.getAllowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\r\n        _approve(account, _msgSender(), newAllowance);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/CLVTokenData.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\n// Stores the CLV user data: token balances and spending allowances.\r\n// Functions are setters, addition and subtraction. Actual token logic resides in CLVToken.sol\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\r\nimport \"@nomiclabs/buidler/console.sol\";\r\n\r\ncontract CLVTokenData is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    // User data for CLV token\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowances;\r\n\r\n    // CLV token logic contract address\r\n    address clvTokenAddress;\r\n\r\n    constructor() public {\r\n        clvTokenAddress = _msgSender();\r\n    }\r\n\r\n    modifier onlyCLVTokenAddress {\r\n        require(_msgSender() == clvTokenAddress, \"CLVTokenData: only clvTokenAddress\");\r\n        _;\r\n    }\r\n\r\n    // --- Balance functions --- \r\n\r\n    function getBalance(address account) external view onlyCLVTokenAddress returns(uint) { \r\n        return balances[account];\r\n    }\r\n\r\n    function setBalance(address account, uint256 newBalance) external  onlyCLVTokenAddress {\r\n        balances[account] = newBalance;\r\n    }\r\n\r\n    function addToBalance(address account, uint256 value) external onlyCLVTokenAddress {\r\n        balances[account] = balances[account].add(value);\r\n    }\r\n\r\n    function subFromBalance(address account, uint256 value) external onlyCLVTokenAddress {\r\n        balances[account] = balances[account].sub(value, 'ERC20: subtracted amount exceeds balance');\r\n    }\r\n\r\n    // --- Allowance functions ---\r\n    \r\n    function getAllowance(address owner, address spender) external view onlyCLVTokenAddress returns(uint) {\r\n        return allowances[owner][spender];\r\n    }\r\n\r\n    function setAllowance(address owner, address spender, uint256 allowance) external onlyCLVTokenAddress {\r\n        allowances[owner][spender] = allowance;\r\n    }\r\n}"
    },
    "contracts/DefaultPool.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\nimport './Interfaces/IPool.sol';\r\nimport '@openzeppelin/contracts/ownership/Ownable.sol';\r\nimport '@openzeppelin/contracts/math/SafeMath.sol';\r\nimport \"@nomiclabs/buidler/console.sol\";\r\n\r\ncontract DefaultPool is Ownable, IPool {\r\n    using SafeMath for uint256;\r\n\r\n    address public poolManagerAddress;\r\n    address public stabilityPoolAddress;\r\n    address public activePoolAddress;\r\n    uint256 public ETH;  // deposited ether tracker\r\n    uint256 public CLV;  // total outstanding CDP debt\r\n\r\n    constructor() public {}\r\n\r\n    // --- Contract setters ---\r\n\r\n    function setPoolManagerAddress(address _poolManagerAddress) public onlyOwner {\r\n        poolManagerAddress = _poolManagerAddress;\r\n        emit PoolManagerAddressChanged(poolManagerAddress);\r\n    }\r\n\r\n    function setActivePoolAddress(address _activePoolAddress) public onlyOwner {\r\n        activePoolAddress = _activePoolAddress;\r\n        emit ActivePoolAddressChanged(activePoolAddress);\r\n    }\r\n\r\n    function setStabilityPoolAddress(address _stabilityPoolAddress) public onlyOwner {\r\n        stabilityPoolAddress = _stabilityPoolAddress;\r\n        emit StabilityPoolAddressChanged(stabilityPoolAddress);\r\n    }\r\n\r\n    // --- Getters for public variables. Required by IPool interface ---\r\n\r\n    function getETH() public view returns(uint) {\r\n        return ETH;\r\n    }\r\n\r\n    function getCLV() public view returns(uint) {\r\n        return CLV;\r\n    }\r\n\r\n    // --- Pool functionality ---\r\n\r\n    function sendETH(address _account, uint _amount) public onlyPoolManager returns(bool) {\r\n        ETH = ETH.sub(_amount);\r\n        (bool success, ) = _account.call.value(_amount)(\"\");  // use call.value()('') as per Consensys latest advice \r\n        require (success == true, 'DefaultPool: transaction reverted');\r\n        emit ETHBalanceUpdated(ETH);\r\n        emit EtherSent(_account, _amount);\r\n        return success;\r\n    }\r\n\r\n    function increaseCLV(uint _amount) public onlyPoolManager () {\r\n        CLV  = CLV.add(_amount);\r\n        emit CLVBalanceUpdated(CLV);\r\n    }\r\n\r\n    function decreaseCLV(uint _amount) public onlyPoolManager () {\r\n        CLV = CLV.sub(_amount);\r\n        emit CLVBalanceUpdated(CLV);\r\n    }\r\n\r\n    /* Returns the raw ether balance at DefaultPool address.  \r\n    Not necessarily equal to the ETH state variable - ether can be forcibly sent to contracts. */\r\n    function getRawETHBalance() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    modifier onlyPoolManager {\r\n        require(_msgSender() == poolManagerAddress, \"DefaultPool: Only the poolManager is authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPoolManagerOrPool {\r\n        require(\r\n            _msgSender() == poolManagerAddress || \r\n            _msgSender() == stabilityPoolAddress || \r\n            _msgSender() == activePoolAddress, \r\n            \"DefaultPool: only receive ETH from Pool or PoolManager\");\r\n        _;\r\n    }\r\n\r\n    function () external payable onlyPoolManagerOrPool {\r\n        ETH = ETH.add(msg.value);\r\n    }\r\n}\r\n"
    },
    "contracts/FunctionCaller.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\nimport './Interfaces/ICDPManager.sol';\r\nimport './Interfaces/ISortedCDPs.sol';\r\nimport '@nomiclabs/buidler/console.sol';\r\nimport './DeciMath.sol';\r\n\r\n// Proxy contract - used for calculating gas of read-only functions in gas calculation scripts.  Not part of the application.\r\n\r\ncontract FunctionCaller {\r\n\r\n    ICDPManager cdpManager;\r\n    address cdpManagerAddress;\r\n\r\n    ISortedCDPs sortedCDPs;\r\n    address sortedCDPsAddress;\r\n\r\n    // --- Dependency setters ---\r\n\r\n    function setCDPManagerAddress(address _cdpManagerAddress) public {\r\n        cdpManagerAddress = _cdpManagerAddress;\r\n        cdpManager = ICDPManager(_cdpManagerAddress);\r\n    }\r\n    \r\n     function setSortedCDPsAddress(address _sortedCDPsAddress) public {\r\n        cdpManagerAddress = _sortedCDPsAddress;\r\n        sortedCDPs = ISortedCDPs(_sortedCDPsAddress);\r\n    }\r\n\r\n    // --- CDPManager functions ---\r\n\r\n    function cdpManager_getCurrentICR (address _address) public returns(uint) {\r\n        cdpManager.getCurrentICR(_address);  \r\n    }\r\n\r\n    function cdpManager_getApproxHint (uint _CR, uint _numTrials) public returns(address) {\r\n        return cdpManager.getApproxHint(_CR, _numTrials);\r\n    }\r\n\r\n    // --- SortedCDPs functions ---\r\n\r\n    function sortedCDPs_findInsertPosition(uint _ICR, address _prevId, address _nextId) public returns(address, address) {\r\n        return sortedCDPs.findInsertPosition(_ICR, _prevId, _nextId);\r\n    }\r\n\r\n    // --- DeciMath functions ---\r\n\r\n    function decimath_accurateMulDiv(uint x, uint y, uint z) public returns(uint fraction) {\r\n        return DeciMath.accurateMulDiv(x ,y, z);\r\n    }\r\n\r\n    function getMin(uint a, uint b) public returns(uint) {\r\n        return DeciMath.getMin(a, b);\r\n    }\r\n\r\n    function decimath_decMul(uint x, uint y) public returns (uint prod) {\r\n        return DeciMath.decMul(x, y);\r\n    }\r\n   \r\n    function decimath_decDiv(uint x, uint y) public returns (uint quotient) {\r\n        return DeciMath.decDiv(x, y);\r\n    }\r\n\r\n    function decimath_div_toDuint(uint x, uint y) public returns (uint quotient) {\r\n        return DeciMath.div_toDuint(x, y);\r\n    }\r\n\r\n    function decimath_mul_uintByDuint( uint x, uint y_duint)public returns (uint prod) {\r\n        return DeciMath.mul_uintByDuint(x, y_duint);\r\n    }\r\n}\r\n\r\n"
    },
    "contracts/Interfaces/IStabilityPool.sol": {
      "content": "interface IStabilityPool {\r\n    // --- Events ---\r\n    event ETHBalanceUpdated(uint _newBalance);\r\n\r\n    event CLVBalanceUpdated(uint _newBalance);\r\n\r\n    event PoolManagerAddressChanged(address _newAddress);\r\n\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n\r\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\r\n\r\n    event EtherSent(address _to, uint _amount);\r\n\r\n    // --- Functions ---\r\n    function getETH() external view returns(uint);\r\n    \r\n    function getCLV() external view returns(uint);\r\n\r\n    function getTotalCLVDeposits() external view returns(uint);\r\n\r\n    function setPoolManagerAddress(address _poolManagerAddress) external;\r\n\r\n    function setActivePoolAddress(address _activePoolAddress) external;\r\n\r\n    function setDefaultPoolAddress(address _defaultPoolAddress) external;\r\n    \r\n    function increaseTotalCLVDeposits(uint _amount) external;\r\n\r\n    function decreaseTotalCLVDeposits(uint _amount)  external;\r\n\r\n    function sendETH(address _account, uint _amount) external returns(bool);\r\n\r\n    function increaseCLV(uint _amount) external;\r\n\r\n    function decreaseCLV(uint _amount) external;\r\n\r\n    function getRawETHBalance() external view returns(uint);\r\n}"
    },
    "contracts/Migrations.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\ncontract Migrations {\r\n  address public owner;\r\n  uint public last_completed_migration;\r\n\r\n  modifier restricted() {\r\n    if (msg.sender == owner) _;\r\n  }\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function setCompleted(uint completed) public restricted {\r\n    last_completed_migration = completed;\r\n  }\r\n\r\n  function upgrade(address new_address) public restricted {\r\n    Migrations upgraded = Migrations(new_address);\r\n    upgraded.setCompleted(last_completed_migration);\r\n  }\r\n}\r\n"
    },
    "contracts/NameRegistry.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\r\nimport \"@nomiclabs/buidler/console.sol\";\r\n\r\ncontract NameRegistry is Ownable {\r\n\r\n    mapping (string => address) public registry;\r\n\r\n    event NewContractRegistered(string _name, address _addr);\r\n    event ContractAddressUpdated(string _name, address _addr);\r\n\r\n    function registerContract(string memory name, address addr) public onlyOwner returns(bool) {\r\n        require(registry[name] == address(0), \"NameReg: name already maps to an addr\");\r\n        registry[name] = addr;\r\n        emit NewContractRegistered(name, addr);\r\n        return true;\r\n    }\r\n\r\n    function updateAddress(string memory name, address addr) public onlyOwner returns(bool) {\r\n        require(registry[name] != address(0), \"NameReg: name does not map to an addr\");\r\n        registry[name] = addr;\r\n        emit ContractAddressUpdated(name, addr);\r\n        return true;\r\n    }\r\n\r\n    function getAddress(string memory name) public view returns(address) {\r\n        require(registry[name] != address(0), \"NameReg: name does not map to an addr\");\r\n        return registry[name];\r\n    }\r\n}"
    },
    "contracts/PoolManager.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\nimport './Interfaces/IPool.sol';\r\nimport './Interfaces/IPoolManager.sol';\r\nimport './Interfaces/ICDPManager.sol';\r\nimport './Interfaces/IStabilityPool.sol';\r\nimport './Interfaces/IPriceFeed.sol';\r\nimport './Interfaces/ICLVToken.sol';\r\nimport './DeciMath.sol';\r\nimport '@openzeppelin/contracts/math/SafeMath.sol';\r\nimport '@openzeppelin/contracts/ownership/Ownable.sol';\r\nimport '@nomiclabs/buidler/console.sol';\r\n\r\n// PoolManager maintains all pools \r\ncontract PoolManager is Ownable, IPoolManager {\r\n    using SafeMath for uint;\r\n\r\n    // --- Events ---\r\n    event CDPManagerAddressChanged(address _newCDPManagerAddress);\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n    event CLVTokenAddressChanged(address _newCLVTokenAddress);\r\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n    \r\n    event UserSnapshotUpdated(uint _CLV, uint _ETH);\r\n    event S_CLVUpdated(uint _S_CLV);\r\n    event S_ETHUpdated(uint _S_ETH);\r\n    event UserDepositChanged(address _user, uint _amount);\r\n    event OverstayPenaltyClaimed(address claimant, uint claimantReward, address depositor, uint remainder);\r\n\r\n    // --- Connected contract declarations ---\r\n    address public cdpManagerAddress;\r\n    ICDPManager cdpManager = ICDPManager(cdpManagerAddress);\r\n\r\n    IPriceFeed priceFeed;\r\n    address public priceFeedAddress;\r\n\r\n    ICLVToken CLV;\r\n    address public clvAddress;\r\n\r\n    IStabilityPool public stabilityPool;\r\n    address public stabilityPoolAddress;\r\n\r\n    IPool public activePool;\r\n    address public activePoolAddress;\r\n\r\n    IPool public defaultPool;\r\n    address public defaultPoolAddress;\r\n   \r\n   // --- Data structures ---\r\n   \r\n    mapping (address => uint) public deposit;\r\n\r\n    struct Snapshot {\r\n        uint ETH;\r\n        uint CLV;\r\n    }\r\n    \r\n    /* Track the sums of accumulated rewards per unit staked: S_CLV and S_ETH. During it's lifetime, each deposit earns:\r\n\r\n    A CLV *loss* of ( deposit * [S_CLV - S_CLV(0)] )\r\n    An ETH *gain* of ( deposit * [S_ETH - S_ETH(0)] )\r\n    \r\n    Where S_CLV(0) and S_ETH(0) are snapshots of S_CLV and S_ETH taken at the instant the deposit was made */\r\n    uint public S_CLV;\r\n    uint public S_ETH;\r\n\r\n    // Map users to their individual snapshots of S_CLV and the S_ETH\r\n    mapping (address => Snapshot) public snapshot;\r\n\r\n    // --- Modifiers ---\r\n    modifier onlyCDPManager() {\r\n        require(_msgSender() == cdpManagerAddress, \"PoolManager: Caller is not the CDPManager\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCDPManagerOrUserIsSender(address _user) {\r\n        require(_msgSender()  == cdpManagerAddress || _user == _msgSender(),\r\n        \"PoolManager: Target CDP must be _msgSender(), otherwise caller must be CDPManager\");\r\n        _;\r\n    }\r\n    modifier onlyStabilityPoolorActivePool {\r\n        require(\r\n            _msgSender() == stabilityPoolAddress ||  _msgSender() ==  activePoolAddress, \r\n            \"PoolManager: Caller is neither StabilityPool nor ActivePool\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {}\r\n\r\n    // --- Dependency setters ---\r\n    function setCDPManagerAddress(address _cdpManagerAddress) public onlyOwner {\r\n        cdpManagerAddress = _cdpManagerAddress;\r\n        cdpManager = ICDPManager(_cdpManagerAddress);\r\n        emit CDPManagerAddressChanged(_cdpManagerAddress);\r\n    }\r\n\r\n     function setPriceFeed(address _priceFeedAddress) public onlyOwner {\r\n        priceFeedAddress = _priceFeedAddress;\r\n        priceFeed = IPriceFeed(_priceFeedAddress);\r\n        emit PriceFeedAddressChanged(_priceFeedAddress);\r\n    }\r\n\r\n    function setCLVToken(address _CLVAddress) public onlyOwner {\r\n        clvAddress = _CLVAddress;\r\n        CLV = ICLVToken(_CLVAddress);\r\n        emit CLVTokenAddressChanged(_CLVAddress);\r\n    }\r\n\r\n    function setStabilityPool(address _stabilityPoolAddress) public onlyOwner {\r\n        stabilityPoolAddress = _stabilityPoolAddress;\r\n        stabilityPool = IStabilityPool(stabilityPoolAddress);\r\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\r\n    }\r\n\r\n    function setActivePool(address _activePoolAddress) public onlyOwner {\r\n        activePoolAddress = _activePoolAddress;\r\n        activePool = IPool(activePoolAddress);\r\n        emit ActivePoolAddressChanged(_activePoolAddress);\r\n    }\r\n\r\n    function setDefaultPool(address _defaultPoolAddress) public onlyOwner {\r\n        defaultPoolAddress = _defaultPoolAddress;\r\n        defaultPool = IPool(defaultPoolAddress);\r\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\r\n    }\r\n\r\n    // --- Getters ---\r\n\r\n    // Return the current ETH balance of the PoolManager contract\r\n    function getBalance() public view returns(uint) {\r\n        return address(this).balance;\r\n    } \r\n    \r\n    // Return the total collateral ratio (TCR) of the system, based on the most recent ETH:USD price\r\n    function getTCR() view public returns (uint) {\r\n        uint totalCollateral = activePool.getETH();\r\n        uint totalDebt = activePool.getCLV();\r\n        uint price = priceFeed.getPrice();\r\n\r\n        // Handle edge cases of div-by-0\r\n        if(totalCollateral == 0 && totalDebt == 0 ) {\r\n            return 1;\r\n        }  else if (totalCollateral != 0 && totalDebt == 0 ) {\r\n            return 2**256 - 1; // TCR is technically infinite\r\n        }\r\n\r\n        // Calculate TCR\r\n        uint collToDebtRatio = DeciMath.div_toDuint(totalCollateral, totalDebt);\r\n        uint TCR = DeciMath.mul_uintByDuint(price, collToDebtRatio);\r\n        return TCR;\r\n    }\r\n\r\n    // Return the total active debt (in CLV) in the system\r\n    function getActiveDebt()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return activePool.getCLV();\r\n    }    \r\n    \r\n    // Return the total active collateral (in ETH) in the system\r\n    function getActiveColl()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return activePool.getETH();\r\n    } \r\n    \r\n    // Return the amount of closed debt (in CLV)\r\n    function getClosedDebt()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return defaultPool.getCLV();\r\n    }    \r\n    \r\n    // Return the amount of closed collateral (in ETH)\r\n    function getLiquidatedColl()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return defaultPool.getETH();\r\n    }\r\n    \r\n    // Return the total CLV in the Stability Pool\r\n    function getStabilityPoolCLV()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return stabilityPool.getCLV();\r\n    }\r\n    \r\n    // Add the received ETH to the total active collateral\r\n    function addColl()\r\n        public\r\n        payable\r\n        onlyCDPManager\r\n        returns (bool)\r\n    {\r\n        // Send ETH to Active Pool and increase its recorded ETH balance\r\n       (bool success, ) = activePoolAddress.call.value(msg.value)(\"\");\r\n       require (success == true, 'PoolManager: transaction to activePool reverted');\r\n       return success;\r\n    }\r\n    \r\n    // Transfer the specified amount of ETH to _account and updates the total active collateral\r\n    function withdrawColl(address _account, uint _ETH)\r\n        public\r\n        onlyCDPManager\r\n        returns (bool)\r\n    {\r\n        activePool.sendETH(_account, _ETH);\r\n        return true;\r\n    }\r\n    \r\n    // Issue the specified amount of CLV to _account and increases the total active debt\r\n    function withdrawCLV(address _account, uint _CLV)\r\n        public\r\n        onlyCDPManager\r\n        returns (bool)\r\n    {\r\n        activePool.increaseCLV(_CLV);\r\n        CLV.mint(_account, _CLV);\r\n                \r\n        return true;\r\n    }\r\n    \r\n    // Burn the specified amount of CLV from _account and decreases the total active debt\r\n    function repayCLV(address _account, uint _CLV)\r\n        public\r\n        onlyCDPManager\r\n        returns (bool)\r\n    {\r\n        activePool.decreaseCLV(_CLV);\r\n        CLV.burn(_account, _CLV);\r\n        \r\n        return true;\r\n    }           \r\n    \r\n    // Update the Active Pool and the Default Pool when a CDP gets closed\r\n    function liquidate(uint _CLV, uint _ETH)\r\n        public\r\n        onlyCDPManager\r\n        returns (bool)\r\n    {\r\n        // Transfer the debt & coll from the Active Pool to the Default Pool\r\n        defaultPool.increaseCLV(_CLV);\r\n        activePool.decreaseCLV(_CLV);\r\n        activePool.sendETH(defaultPoolAddress, _ETH);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Update the Active Pool and the Default Pool when a CDP obtains a default share\r\n    function applyPendingRewards(uint _CLV, uint _ETH)\r\n        public\r\n        onlyCDPManager\r\n        returns (bool)\r\n    {\r\n        // Transfer the debt & coll from the Default Pool to the Active Pool\r\n        defaultPool.decreaseCLV(_CLV);\r\n        activePool.increaseCLV(_CLV);\r\n        defaultPool.sendETH(activePoolAddress, _ETH);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Burn the received CLV, transfers the redeemed ETH to _account and updates the Active Pool\r\n    function redeemCollateral(address _account, uint _CLV, uint _ETH)\r\n        public\r\n        onlyCDPManager\r\n        returns (bool)\r\n    {\r\n        // Update Active Pool CLV, and send ETH to account\r\n        activePool.decreaseCLV(_CLV);\r\n        activePool.sendETH(_account, _ETH);\r\n\r\n        CLV.burn(_account, _CLV);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Return the accumulated change, for the user, for the duration that this deposit was held\r\n    function getCurrentETHGain(address _user) internal view returns(uint) {\r\n        uint userDeposit = deposit[_user];\r\n        uint snapshotETH = snapshot[_user].ETH;  // duint\r\n        uint ETHGainPerUnitStaked = S_ETH.sub(snapshotETH);  // duint\r\n\r\n        return DeciMath.mul_uintByDuint(userDeposit, ETHGainPerUnitStaked); // uint\r\n    }\r\n\r\n    function getCurrentCLVLoss(address _user) internal view returns(uint) {\r\n        uint userDeposit = deposit[_user];\r\n        uint snapshotCLV = snapshot[_user].CLV; // duint\r\n        uint CLVLossPerUnitStaked = S_CLV.sub(snapshotCLV); // duint\r\n\r\n        return DeciMath.mul_uintByDuint(userDeposit, CLVLossPerUnitStaked); // uint\r\n    }\r\n\r\n    // --- Internal StabilityPool functions --- \r\n\r\n    // Deposit _amount CLV from _address, to the Stability Pool.\r\n    function depositCLV(address _address, uint _amount) internal returns(bool) {\r\n        require(deposit[_address] == 0, \"PoolManager: user already has a StabilityPool deposit\");\r\n        require(CLV.balanceOf(_address) >= _amount, \"PoolManager: user has insufficient CLV balance to make deposit\");\r\n        \r\n        // Transfer the CLV tokens from the user to the Stability Pool's address, and update its recorded CLV\r\n        CLV.sendToPool(_address, stabilityPoolAddress, _amount);\r\n        stabilityPool.increaseCLV(_amount);\r\n        stabilityPool.increaseTotalCLVDeposits(_amount);\r\n        \r\n        // Record the deposit made by user\r\n        deposit[_address] = _amount;\r\n    \r\n        // Record new individual snapshots of the running totals S_CLV and S_ETH for the user\r\n        snapshot[_address].CLV = S_CLV;\r\n        snapshot[_address].ETH = S_ETH;\r\n\r\n        emit UserSnapshotUpdated(S_CLV, S_ETH);\r\n        emit UserDepositChanged(_address, _amount);\r\n        return true;\r\n    }\r\n\r\n   // Transfers _address's entitled CLV (CLVDeposit - CLVLoss) and their ETHGain, to _address.\r\n    function retrieveToUser(address _address) internal returns(uint[2] memory) {\r\n        uint userDeposit = deposit[_address];\r\n\r\n        uint ETHShare = getCurrentETHGain(_address);\r\n        uint CLVLoss = getCurrentCLVLoss(_address);\r\n        uint CLVShare;\r\n\r\n        // If user's deposit is an 'overstay', they retrieve 0 CLV\r\n        if (CLVLoss > userDeposit) {\r\n            CLVShare = 0;\r\n        } else {\r\n            CLVShare = userDeposit.sub(CLVLoss);\r\n        }\r\n\r\n        // Update deposit and snapshots\r\n        deposit[_address] = 0;\r\n\r\n        snapshot[_address].CLV = S_CLV;\r\n        snapshot[_address].ETH = S_ETH;\r\n\r\n        emit UserDepositChanged(_address, deposit[_address]);\r\n        emit UserSnapshotUpdated(S_CLV, S_ETH);\r\n\r\n        // Send CLV to user and decrease CLV in Pool\r\n        CLV.returnFromPool(stabilityPoolAddress, _address, DeciMath.getMin(CLVShare, stabilityPool.getCLV()));\r\n        stabilityPool.decreaseCLV(CLVShare);\r\n        stabilityPool.decreaseTotalCLVDeposits(userDeposit);\r\n\r\n        // Send ETH to user\r\n        stabilityPool.sendETH(_address, ETHShare);\r\n\r\n        uint[2] memory shares = [CLVShare, ETHShare];\r\n        return shares;\r\n    }\r\n\r\n    // Transfer _address's entitled CLV (userDeposit - CLVLoss) to _address, and their ETHGain to their CDP.\r\n    function retrieveToCDP(address _address) internal returns(uint[2] memory) {\r\n        uint userDeposit = deposit[_address];\r\n        require(userDeposit > 0, 'PoolManager: User must have a non-zero deposit');\r\n        \r\n        uint ETHShare = getCurrentETHGain(_address);\r\n        uint CLVLoss = getCurrentCLVLoss(_address);\r\n\r\n        uint CLVShare;\r\n\r\n        // If user's deposit is an 'overstay', they retrieve 0 CLV\r\n        if (CLVLoss > userDeposit) {\r\n            CLVShare = 0;\r\n        } else {\r\n            CLVShare = userDeposit.sub(CLVLoss);\r\n        }\r\n\r\n        // Update deposit and snapshots\r\n        deposit[_address] = 0;\r\n\r\n        snapshot[_address].CLV = S_CLV;\r\n        snapshot[_address].ETH = S_ETH;\r\n\r\n        emit UserDepositChanged(_address, deposit[_address]);\r\n        emit UserSnapshotUpdated(S_CLV, S_ETH);\r\n\r\n        // Send CLV to user and decrease CLV in StabilityPool\r\n        CLV.returnFromPool(stabilityPoolAddress, _address, DeciMath.getMin(CLVShare, stabilityPool.getCLV()));\r\n        stabilityPool.decreaseCLV(CLVShare);\r\n        stabilityPool.decreaseTotalCLVDeposits(userDeposit);\r\n\r\n        // Pull ETHShare from StabilityPool, and send to CDP\r\n        stabilityPool.sendETH(address(this), ETHShare);\r\n        //TODO: Potentially use getApproxHint() here\r\n        cdpManager.addColl.value(ETHShare)(_address, _address);\r\n        \r\n        uint[2] memory shares = [CLVShare, ETHShare];\r\n        return shares;\r\n    }\r\n\r\n    // --- External StabilityPool Functions ---\r\n\r\n    /* Send ETHGain to user's address, and updates their deposit, \r\n    setting newDeposit = (oldDeposit - CLVLoss) + amount. */\r\n    function provideToSP(uint _amount) external returns(bool) {\r\n        cdpManager.checkTCRAndSetRecoveryMode();\r\n\r\n        address user = _msgSender();\r\n        uint[2] memory returnedVals = retrieveToUser(user);\r\n\r\n        uint returnedCLV = returnedVals[0];\r\n\r\n        uint newDeposit = returnedCLV + _amount;\r\n        depositCLV(msg.sender, newDeposit);\r\n\r\n        return true;\r\n    }\r\n\r\n    /* Withdraw _amount of CLV and the caller’s entire ETHGain from the \r\n    Stability Pool, and updates the caller’s reduced deposit. \r\n\r\n    If  _amount is 0, the user only withdraws their ETHGain, no CLV.\r\n    If _amount > (userDeposit - CLVLoss), the user withdraws all their ETHGain and all available CLV.\r\n\r\n    In all cases, the entire ETHGain is sent to user, and the CLVLoss is applied to their deposit. */\r\n    function withdrawFromSP(uint _amount) external returns(bool) {\r\n        cdpManager.checkTCRAndSetRecoveryMode();\r\n\r\n        address user = _msgSender();\r\n        uint userDeposit = deposit[user];\r\n        require(userDeposit > 0, 'PoolManager: User must have a non-zero deposit');\r\n\r\n        // Retrieve all CLV and ETH for the user\r\n        uint[2] memory returnedVals = retrieveToUser(user);\r\n\r\n        uint returnedCLV = returnedVals[0];\r\n\r\n        // If requested withdrawal amount is less than available CLV, re-deposit the difference.\r\n        if (_amount < returnedCLV) {\r\n            depositCLV(user, returnedCLV.sub(_amount));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /* Transfer the caller’s entire ETHGain from the Stability Pool to the caller’s CDP. \r\n    Applies their CLVLoss to the deposit. */\r\n    function withdrawFromSPtoCDP(address _user) external onlyCDPManagerOrUserIsSender(_user) returns(bool) {\r\n        cdpManager.checkTCRAndSetRecoveryMode();\r\n\r\n        uint userDeposit = deposit[_user];\r\n        if (userDeposit == 0) { return false; }\r\n\r\n        // Retrieve all CLV to user's CLV balance, and ETH to their CDP\r\n        uint[2] memory returnedVals = retrieveToCDP(_user);\r\n\r\n        uint returnedCLV = returnedVals[0];\r\n\r\n        // Update deposit, applying CLVLoss\r\n        depositCLV(_user, returnedCLV);\r\n\r\n        return true;\r\n    }\r\n\r\n    /* Withdraw a 'penalty' fraction of an overstayed depositor's ETHGain.  \r\n    \r\n    Callable by anyone when _depositor's CLVLoss > deposit. */\r\n    function withdrawPenaltyFromSP(address _address) external returns(bool) {\r\n        cdpManager.checkTCRAndSetRecoveryMode();\r\n\r\n        address claimant = _msgSender();\r\n        address depositor = _address;\r\n        \r\n        uint CLVLoss = getCurrentCLVLoss(depositor);\r\n        uint depositAmount = deposit[depositor];\r\n        require(CLVLoss > depositAmount, \"PoolManager: depositor has not overstayed\");\r\n\r\n        uint ETHGain = getCurrentETHGain(depositor);\r\n\r\n        /* Depositor is penalised for overstaying - i.e. letting CLVLoss grow larger than their deposit.\r\n       \r\n        Depositor's ETH entitlement is reduced to ETHGain * (deposit/CLVLoss).\r\n        The claimant retrieves ETHGain * (1 - deposit/CLVLoss). */\r\n        uint ratio = DeciMath.div_toDuint(depositAmount, CLVLoss);  // duint\r\n        uint depositorRemainder = DeciMath.mul_uintByDuint(ETHGain, ratio); // uint\r\n        uint claimantReward = ETHGain.sub(depositorRemainder);\r\n        \r\n        // Update deposit and snapshots\r\n        deposit[depositor] = 0;\r\n        snapshot[depositor].CLV = S_CLV;\r\n        snapshot[depositor].ETH = S_ETH;\r\n\r\n        emit UserDepositChanged(depositor, deposit[depositor]);\r\n        emit UserSnapshotUpdated(S_CLV, S_ETH);\r\n\r\n        // Send reward to claimant, and remainder to depositor\r\n        stabilityPool.sendETH(claimant, claimantReward);\r\n        stabilityPool.sendETH(depositor, depositorRemainder);\r\n        emit OverstayPenaltyClaimed(claimant, claimantReward, depositor, depositorRemainder);\r\n\r\n        return true;\r\n    }\r\n\r\n     /* Cancel out the specified _debt against the CLV contained in the Stability Pool (as far as possible)  \r\n    and transfers the CDP's ETH collateral from ActivePool to StabilityPool. \r\n    Returns the amount of debt that could not be cancelled, and the corresponding ether.\r\n    Only callable from close() and closeCDPs() functions in CDPManager */\r\n    function offset(uint _debt, uint _coll) external payable onlyCDPManager returns (uint[2] memory) \r\n    {    \r\n        uint[2] memory remainder;\r\n        uint totalCLVDeposits = stabilityPool.getTotalCLVDeposits();\r\n        uint CLVinPool = stabilityPool.getCLV();\r\n        \r\n        // When Stability Pool has no CLV or no deposits, return all debt and coll\r\n        if (CLVinPool == 0 || totalCLVDeposits == 0 ) {\r\n            remainder[0] = _debt;\r\n            remainder[1] = _coll;\r\n            return remainder;\r\n        }\r\n        \r\n        // If the debt is larger than the deposited CLV, offset an amount of debt corresponding to the latter\r\n        uint debtToOffset = DeciMath.getMin(_debt, CLVinPool);\r\n        // Collateral to be added in proportion to the debt that is cancelled\r\n        uint debtRatio =  DeciMath.div_toDuint(debtToOffset, _debt);\r\n        uint collToAdd = DeciMath.mul_uintByDuint(_coll, debtRatio);\r\n        \r\n        // Update the running total S_CLV by adding the ratio between the distributed debt and the CLV in the pool\r\n        uint CLVLossPerUnitStaked = DeciMath.div_toDuint(debtToOffset, totalCLVDeposits);\r\n        S_CLV = S_CLV.add(CLVLossPerUnitStaked);\r\n        emit S_CLVUpdated(S_CLV);\r\n        // Update the running total S_ETH by adding the ratio between the distributed collateral and the ETH in the pool\r\n        uint ETHGainPerUnitStaked = DeciMath.div_toDuint(collToAdd, totalCLVDeposits);\r\n        S_ETH = S_ETH.add(ETHGainPerUnitStaked);\r\n        emit S_ETHUpdated(S_ETH);\r\n        // Cancel the liquidated CLV debt with the CLV in the stability pool\r\n        activePool.decreaseCLV(debtToOffset);  \r\n        stabilityPool.decreaseCLV(debtToOffset); \r\n        // Send ETH from Active Pool to Stability Pool\r\n        activePool.sendETH(stabilityPoolAddress, collToAdd);  \r\n        \r\n        // Burn the debt that was successfully offset\r\n        CLV.burn(stabilityPoolAddress, debtToOffset);\r\n        \r\n        // Return the amount of debt & coll that could not be offset against the Stability Pool due to insufficiency\r\n        remainder[0] = _debt.sub(debtToOffset);\r\n        remainder[1] = _coll.sub(collToAdd);\r\n        return remainder;\r\n    }\r\n\r\n    function () external payable onlyStabilityPoolorActivePool {}\r\n}    "
    },
    "contracts/PriceFeed.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport '@openzeppelin/contracts/ownership/Ownable.sol';\r\nimport './Interfaces/ICDPManager.sol';\r\nimport \"@nomiclabs/buidler/console.sol\";\r\n\r\n// A mock ETH:USD price oracle\r\ncontract PriceFeed is Ownable {\r\n    using SafeMath for uint;\r\n    \r\n    uint constant DIGITS = 1e18;\r\n    uint public price = 200 * DIGITS;  \r\n   \r\n    constructor() public {\r\n    }   \r\n   \r\n    address cdpManagerAddress;\r\n    ICDPManager cdpManager;\r\n\r\n    event PriceUpdated(uint _newPrice);\r\n    event CDPManagerAddressChanged(address _cdpManagerAddress);\r\n\r\n    function setCDPManagerAddress(address _cdpManagerAddress) public onlyOwner {\r\n        cdpManagerAddress = _cdpManagerAddress;\r\n        cdpManager = ICDPManager(_cdpManagerAddress);\r\n        emit CDPManagerAddressChanged(_cdpManagerAddress);\r\n    }\r\n\r\n    function setPrice(uint _price) public onlyOwner returns (bool) {\r\n        price = _price.mul(DIGITS);\r\n        cdpManager.checkTCRAndSetRecoveryMode();\r\n        emit PriceUpdated(price);\r\n        return true;\r\n    }    \r\n    \r\n    function getPrice() public returns (uint) {\r\n        return price;\r\n    }  \r\n}\r\n"
    },
    "contracts/SortedCDPs.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\nimport \"./Interfaces/ICDPManager.sol\";\r\nimport '@openzeppelin/contracts/math/SafeMath.sol';\r\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\r\nimport \"@nomiclabs/buidler/console.sol\";\r\n\r\n/* \r\nA sorted doubly linked list with nodes sorted in descending order, based on current ICRs of active CDPs. \r\nOptionally accepts insert position hints.\r\n\r\nICRs are computed dynamically at runtime, and not stored on the Node. This is because ICRs of active CDPs \r\nchange dynamically as liquidation events occur.\r\n\r\nThe list relies on the fact that liquidation events preserve ordering: a liquidation decreases the ICRs of all active CDPs, \r\nbut maintains their order. A node inserted based on current ICR will maintain the correct position, \r\nrelative to it's peers, as rewards accumulate. Thus, Nodes remain sorted by current ICR.\r\n\r\nNodes need only be re-inserted upon a CDP operation - when the owner adds or removes collateral or debt.\r\n\r\nThe list is a modification of the following audited SortedDoublyLinkedList:\r\nhttps://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\r\n\r\nIn our variant, keys have been removed, and all ICR checks in functions now compare an ICR argument to the current ICR, \r\ncalculated at runtime. Data is stored in the 'data' state variable.\r\n*/\r\ncontract SortedCDPs is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    event CDPManagerAddressChanged(address _newCDPlManagerAddress);\r\n\r\n    ICDPManager cdpManager;\r\n    address CDPManagerAddress;\r\n\r\n    // Information for a node in the list\r\n    struct Node {\r\n        bool exists;\r\n        address nextId;                  // Id of next node (smaller ICR) in the list\r\n        address prevId;                  // Id of previous node (larger ICR) in the list\r\n    }\r\n\r\n    // Information for the list\r\n    struct Data {\r\n        address head;                        // Head of the list. Also the node in the list with the largest ICR\r\n        address tail;                        // Tail of the list. Also the node in the list with the smallest ICR\r\n        uint256 maxSize;                     // Maximum size of the list\r\n        uint256 size;                        // Current size of the list\r\n        mapping (address => Node) nodes;     // Track the corresponding ids for each node in the list\r\n    }\r\n\r\n    Data data;\r\n\r\n    function setCDPManager(address _CDPManagerAddress) public onlyOwner {\r\n        CDPManagerAddress = _CDPManagerAddress;\r\n        cdpManager = ICDPManager(_CDPManagerAddress);\r\n        emit CDPManagerAddressChanged(_CDPManagerAddress);\r\n    }\r\n\r\n    /*\r\n     * @dev Set the maximum size of the list\r\n     * @param _size Maximum size\r\n     */\r\n    function setMaxSize(uint256 _size) public {\r\n        // New max size must be greater than old max size\r\n        require(_size > data.maxSize);\r\n\r\n        data.maxSize = _size;\r\n    }\r\n\r\n    /*\r\n     * @dev Add a node to the list\r\n     * @param _id Node's id\r\n     * @param _ICR Node's ICR\r\n     * @param _prevId Id of previous node for the insert position\r\n     * @param _nextId Id of next node for the insert position\r\n     */\r\n    function insert(address _id, uint256 _ICR, address _prevId, address _nextId) public {\r\n        // List must not be full\r\n        require(!isFull());\r\n        // List must not already contain node\r\n        require(!contains(_id));\r\n        // Node id must not be null\r\n        require(_id != address(0));\r\n        // ICR must be non-zero\r\n        require(_ICR > 0);\r\n\r\n        address prevId = _prevId;\r\n        address nextId = _nextId;\r\n\r\n        if (!validInsertPosition(_ICR, prevId, nextId)) {\r\n            // Sender's hint was not a valid insert position\r\n            // Use sender's hint to find a valid insert position\r\n            (prevId, nextId) = findInsertPosition(_ICR, prevId, nextId);\r\n        }\r\n\r\n        data.nodes[_id].exists = true;\r\n\r\n        if (prevId == address(0) && nextId == address(0)) {\r\n            // Insert as head and tail\r\n            data.head = _id;\r\n            data.tail = _id;\r\n        } else if (prevId == address(0)) {\r\n            // Insert before `prevId` as the head\r\n            data.nodes[_id].nextId = data.head;\r\n            data.nodes[data.head].prevId = _id;\r\n            data.head = _id;\r\n        } else if (nextId == address(0)) {\r\n            // Insert after `nextId` as the tail\r\n            data.nodes[_id].prevId = data.tail;\r\n            data.nodes[data.tail].nextId = _id;\r\n            data.tail = _id;\r\n        } else {\r\n            // Insert at insert position between `prevId` and `nextId`\r\n            data.nodes[_id].nextId = nextId;\r\n            data.nodes[_id].prevId = prevId;\r\n            data.nodes[prevId].nextId = _id;\r\n            data.nodes[nextId].prevId = _id;\r\n        }\r\n\r\n        data.size = data.size.add(1);\r\n    }\r\n\r\n    /*\r\n     * @dev Remove a node from the list\r\n     * @param _id Node's id\r\n     */\r\n    function remove(address _id) public {\r\n        // List must contain the node\r\n        require(contains(_id));\r\n\r\n        if (data.size > 1) {\r\n            // List contains more than a single node\r\n            if (_id == data.head) {\r\n                // The removed node is the head\r\n                // Set head to next node\r\n                data.head = data.nodes[_id].nextId;\r\n                // Set prev pointer of new head to null\r\n                data.nodes[data.head].prevId = address(0);\r\n            } else if (_id == data.tail) {\r\n                // The removed node is the tail\r\n                // Set tail to previous node\r\n                data.tail = data.nodes[_id].prevId;\r\n                // Set next pointer of new tail to null\r\n                data.nodes[data.tail].nextId = address(0);\r\n            } else {\r\n                // The removed node is neither the head nor the tail\r\n                // Set next pointer of previous node to the next node\r\n                data.nodes[data.nodes[_id].prevId].nextId = data.nodes[_id].nextId;\r\n                // Set prev pointer of next node to the previous node\r\n                data.nodes[data.nodes[_id].nextId].prevId = data.nodes[_id].prevId;\r\n            }\r\n        } else {\r\n            // List contains a single node\r\n            // Set the head and tail to null\r\n            data.head = address(0);\r\n            data.tail = address(0);\r\n        }\r\n\r\n        delete data.nodes[_id];\r\n        data.size = data.size.sub(1);\r\n    }\r\n\r\n    /*\r\n     * @dev Re-insert the node at a new position, based on its new ICR\r\n     * @param _id Node's id\r\n     * @param _newICR Node's new ICR\r\n     * @param _prevId Id of previous node for the new insert position\r\n     * @param _nextId Id of next node for the new insert position\r\n     */\r\n    function reInsert(address _id, uint256 _newICR, address _prevId, address _nextId) public {\r\n        // List must contain the node\r\n        require(contains(_id));\r\n\r\n        // Remove node from the list\r\n        remove(_id);\r\n\r\n        if (_newICR > 0) {\r\n            // Insert node if it has a non-zero ICR\r\n            insert(_id, _newICR, _prevId, _nextId);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if the list contains a node\r\n     * @param _transcoder Address of transcoder\r\n     */\r\n    function contains(address _id) public view returns (bool) {\r\n        return data.nodes[_id].exists;\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if the list is full\r\n     */\r\n    function isFull() public view returns (bool) {\r\n        return data.size == data.maxSize;\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if the list is empty\r\n     */\r\n    function isEmpty() public view returns (bool) {\r\n        return data.size == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the current size of the list\r\n     */\r\n    function getSize() public view returns (uint256) {\r\n        return data.size;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the maximum size of the list\r\n     */\r\n    function getMaxSize() public view returns (uint256) {\r\n        return data.maxSize;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first node in the list (node with the largest ICR)\r\n     */\r\n    function getFirst() public view returns (address) {\r\n        return data.head;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the last node in the list (node with the smallest ICR)\r\n     */\r\n    function getLast() public view returns (address) {\r\n        return data.tail;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the next node (with a smaller ICR) in the list for a given node\r\n     * @param _id Node's id\r\n     */\r\n    function getNext(address _id) public view returns (address) {\r\n        return data.nodes[_id].nextId;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the previous node (with a larger ICR) in the list for a given node\r\n     * @param _id Node's id\r\n     */\r\n    function getPrev(address _id) public view returns (address) {\r\n        return data.nodes[_id].prevId;\r\n    }\r\n\r\n    /*\r\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given ICR\r\n     * @param _ICR Node's ICR\r\n     * @param _prevId Id of previous node for the insert position\r\n     * @param _nextId Id of next node for the insert position\r\n     */\r\n    function validInsertPosition(uint256 _ICR, address _prevId, address _nextId) public view returns (bool) {\r\n        if (_prevId == address(0) && _nextId == address(0)) {\r\n            // `(null, null)` is a valid insert position if the list is empty\r\n            return isEmpty();\r\n        } else if (_prevId == address(0)) {\r\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\r\n            return data.head == _nextId && _ICR >= cdpManager.getCurrentICR(_nextId);\r\n        } else if (_nextId == address(0)) {\r\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\r\n            return data.tail == _prevId && _ICR <= cdpManager.getCurrentICR(_prevId);\r\n        } else {\r\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_ICR` falls between the two nodes' ICRs\r\n            return data.nodes[_prevId].nextId == _nextId && \r\n                   cdpManager.getCurrentICR(_prevId) >= _ICR && \r\n                   _ICR >= cdpManager.getCurrentICR(_nextId);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Descend the list (larger ICRs to smaller ICRs) to find a valid insert position\r\n     * @param _ICR Node's ICR\r\n     * @param _startId Id of node to start ascending the list from\r\n     */\r\n    function descendList(uint256 _ICR, address _startId) private view returns (address, address) {\r\n        // If `_startId` is the head, check if the insert position is before the head\r\n        if (data.head == _startId && _ICR >= cdpManager.getCurrentICR(_startId)) {\r\n            return (address(0), _startId);\r\n        }\r\n\r\n        address prevId = _startId;\r\n        address nextId = data.nodes[prevId].nextId;\r\n\r\n        // Descend the list until we reach the end or until we find a valid insert position\r\n        while (prevId != address(0) && !validInsertPosition(_ICR, prevId, nextId)) {\r\n            prevId = data.nodes[prevId].nextId;\r\n            nextId = data.nodes[prevId].nextId;\r\n        }\r\n\r\n        return (prevId, nextId);\r\n    }\r\n\r\n    /*\r\n     * @dev Ascend the list (smaller ICRs to larger ICRs) to find a valid insert position\r\n     * @param _ICR Node's ICR\r\n     * @param _startId Id of node to start descending the list from\r\n     */\r\n    function ascendList(uint256 _ICR, address _startId) private view returns (address, address) {\r\n        // If `_startId` is the tail, check if the insert position is after the tail\r\n        if (data.tail == _startId && _ICR <= cdpManager.getCurrentICR(_startId)) {\r\n            return (_startId, address(0));\r\n        }\r\n\r\n        address nextId = _startId;\r\n        address prevId = data.nodes[nextId].prevId;\r\n\r\n        // Ascend the list until we reach the end or until we find a valid insertion point\r\n        while (nextId != address(0) && !validInsertPosition(_ICR, prevId, nextId)) {\r\n            nextId = data.nodes[nextId].prevId;\r\n            prevId = data.nodes[nextId].prevId;\r\n        }\r\n\r\n        return (prevId, nextId);\r\n    }\r\n\r\n    /*\r\n     * @dev Find the insert position for a new node with the given ICR\r\n     * @param _ICR Node's ICR\r\n     * @param _prevId Id of previous node for the insert position\r\n     * @param _nextId Id of next node for the insert position\r\n     */\r\n    function findInsertPosition(uint256 _ICR, address _prevId, address _nextId) public view returns (address, address) {\r\n        address prevId = _prevId;\r\n        address nextId = _nextId;\r\n\r\n        if (prevId != address(0)) {\r\n            if (!contains(prevId) || _ICR > cdpManager.getCurrentICR(prevId)) {\r\n                // `prevId` does not exist anymore or now has a smaller ICR than the given ICR\r\n                prevId = address(0);\r\n            }\r\n        }\r\n\r\n        if (nextId != address(0)) {\r\n            if (!contains(nextId) || _ICR < cdpManager.getCurrentICR(nextId)) {\r\n                // `nextId` does not exist anymore or now has a larger ICR than the given ICR\r\n                nextId = address(0);\r\n            }\r\n        }\r\n\r\n        if (prevId == address(0) && nextId == address(0)) {\r\n            // No hint - descend list starting from head\r\n            return descendList(_ICR, data.head);\r\n        } else if (prevId == address(0)) {\r\n            // No `prevId` for hint - ascend list starting from `nextId`\r\n            return ascendList(_ICR, nextId);\r\n        } else if (nextId == address(0)) {\r\n            // No `nextId` for hint - descend list starting from `prevId`\r\n            return descendList(_ICR, prevId);\r\n        } else {\r\n            // Descend list starting from `prevId`\r\n            return descendList(_ICR, prevId);\r\n        }\r\n    }\r\n}"
    },
    "contracts/StabilityPool.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\nimport './Interfaces/IStabilityPool.sol';\r\nimport '@openzeppelin/contracts/ownership/Ownable.sol';\r\nimport '@openzeppelin/contracts/math/SafeMath.sol';\r\nimport \"@nomiclabs/buidler/console.sol\";\r\n\r\ncontract StabilityPool is Ownable, IStabilityPool {\r\n    using SafeMath for uint256;\r\n\r\n    address public poolManagerAddress;\r\n    address public defaultPoolAddress;\r\n    address public activePoolAddress;\r\n    uint256 public ETH;  // deposited ether tracker\r\n    // Total CLV held in the pool. Changes when users deposit/withdraw, and when CDP debt is offset.\r\n    uint256 public CLV;  \r\n\r\n    // Total user CLV deposits. Used in proportional reward calculation in PoolManager. \r\n    //  Only changes when users deposit/withdraw.\r\n    uint256 public totalCLVDeposits; \r\n\r\n    constructor() public {}\r\n\r\n    // --- Contract setters ---\r\n\r\n    function setPoolManagerAddress(address _poolManagerAddress) public onlyOwner {\r\n        poolManagerAddress = _poolManagerAddress;\r\n        emit PoolManagerAddressChanged(poolManagerAddress);\r\n    }\r\n\r\n    function setActivePoolAddress(address _activePoolAddress) public onlyOwner {\r\n        activePoolAddress = _activePoolAddress;\r\n        emit ActivePoolAddressChanged(activePoolAddress);\r\n    }\r\n    \r\n    function setDefaultPoolAddress(address _defaultPoolAddress) public onlyOwner {\r\n        defaultPoolAddress = _defaultPoolAddress; \r\n        emit DefaultPoolAddressChanged(defaultPoolAddress);\r\n    }\r\n\r\n    // --- Getters for public variables. Required by IPool interface ---\r\n\r\n    function getETH() public view returns(uint) {\r\n        return ETH;\r\n    }\r\n\r\n    function getCLV() public view returns(uint) {\r\n        return CLV;\r\n    }\r\n\r\n    function getTotalCLVDeposits() public view returns(uint) {\r\n        return totalCLVDeposits;\r\n    }\r\n\r\n    // --- Pool functionality ---\r\n\r\n    function sendETH(address _account, uint _amount) public onlyPoolManager returns(bool){\r\n        ETH = ETH.sub(_amount);\r\n        (bool success, ) = _account.call.value(_amount)(\"\");  // use call.value()('') as per Consensys latest advice \r\n        require (success == true, 'StabilityPool: transaction reverted');\r\n        emit ETHBalanceUpdated(ETH);\r\n        emit EtherSent(_account, _amount);\r\n        return success;\r\n    }\r\n\r\n    function increaseCLV(uint _amount) public onlyPoolManager () {\r\n        CLV  = CLV.add(_amount);\r\n        emit CLVBalanceUpdated(CLV);\r\n    }\r\n\r\n    function decreaseCLV(uint _amount) public onlyPoolManager () {\r\n        CLV = CLV.sub(_amount);\r\n        emit CLVBalanceUpdated(CLV);\r\n    }\r\n\r\n    function increaseTotalCLVDeposits(uint _amount) public onlyPoolManager () {\r\n        totalCLVDeposits = totalCLVDeposits.add(_amount);\r\n    }\r\n\r\n    function decreaseTotalCLVDeposits(uint _amount) public onlyPoolManager () {\r\n        totalCLVDeposits = totalCLVDeposits.sub(_amount);\r\n    }\r\n\r\n    /* Returns the raw ether balance at StabilityPool address.  \r\n    Not necessarily equal to the ETH state variable - ether can be forcibly sent to contracts. */\r\n    function getRawETHBalance() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    modifier onlyPoolManager {\r\n        require(_msgSender() == poolManagerAddress, \"StabilityPool: Only the poolManager is authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPoolManagerOrPool {\r\n        require(\r\n            _msgSender() == poolManagerAddress || \r\n            _msgSender() == activePoolAddress || \r\n            _msgSender() == defaultPoolAddress, \r\n            \"StabilityPool: only receive ETH from Pool or PoolManager\");\r\n        _;\r\n    }\r\n\r\n    function () external payable onlyPoolManagerOrPool {\r\n        ETH = ETH.add(msg.value);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}